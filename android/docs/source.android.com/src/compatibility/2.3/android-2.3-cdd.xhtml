<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Android 2.3 Compatibility Definition</title>
<link rel="stylesheet" type="text/css" href="cdd.css"/>
</head>
<body>
<div><img src="header.jpg" alt="Android logo"/></div>
<h1>Android 2.3 Compatibility Definition</h1>
<!-- <span style="color: red; font-weight: bold;"><h2>DRAFT</h2></span> -->
<p>Copyright &copy; 2010, Google Inc. All rights reserved.<br/>
<a href="mailto:compatibility@android.com">compatibility@android.com</a>
</p>

<h2> Table of Contents</h2>
<div style="margin-left: 2em;">
  <a href="#section-1">1. Introduction</a><br/>
  <a href="#section-2">2. Resources</a><br/>
  <a href="#section-3">3. Software</a><br/>
  <div style="margin-left: 2em;">
    <a href="#section-3.1">3.1. Managed API Compatibility</a><br/>
    <a href="#section-3.2">3.2. Soft API Compatibility</a><br/>
    <div style="margin-left: 2em;">
      <a href="#section-3.2.1">3.2.1. Permissions</a><br/>
      <a href="#section-3.2.3">3.2.2. Build Parameters</a><br/>
      <a href="#section-3.2.3">3.2.3. Intent Compatibility</a><br/>
      <div style="margin-left: 2em;">
        <a href="#section-3.2.3.1">3.2.3.1. Core Application Intents</a><br/>
        <a href="#section-3.2.3.2">3.2.3.2. Intent Overrides</a><br/>
        <a href="#section-3.2.3.3">3.2.3.3. Intent Namespaces</a><br/>
        <a href="#section-3.2.3.4">3.2.3.4. Broadcast Intents</a><br/>
      </div>
    </div>
    <a href="#section-3.3">3.3. Native API Compatibility</a><br/>
    <a href="#section-3.4">3.4. Web Compatibility</a><br/>
    <div style="margin-left: 2em;">
      <a href="#section-3.4.1">3.4.1. WebView Compatibility</a><br/>
      <a href="#section-3.4.2">3.4.2. Browser Compatibility</a><br/>
    </div>
    <a href="#section-3.5">3.5. API Behavioral Compatibility</a><br/>
    <a href="#section-3.6">3.6. API Namespaces</a><br/>
    <a href="#section-3.7">3.7. Virtual Machine Compatibility</a><br/>
    <a href="#section-3.8">3.8. User Interface Compatibility</a><br/>
    <div style="margin-left: 2em;">
      <a href="#section-3.8.1">3.8.1. Widgets</a><br/>
      <a href="#section-3.8.2">3.8.2. Notifications</a><br/>
      <a href="#section-3.8.3">3.8.3. Search</a><br/>
      <a href="#section-3.8.4">3.8.4. Toasts</a><br/>
      <a href="#section-3.8.5">3.8.5. Live Wallpapers</a><br/>
    </div>
  </div>
  <a href="#section-4">4. Application Packaging Compatibility</a><br/>
  <a href="#section-5">5. Multimedia Compatibility</a><br/>
    <div style="margin-left: 2em;">
      <a href="#section-5.1">5.1. Media Codecs</a><br/>
      <a href="#section-5.1.1">5.1.1. Media Decoders</a><br/>
      <a href="#section-5.1.2">5.1.2. Media Encoders</a><br/>
      <a href="#section-5.2">5.2. Audio Recording</a><br/>
      <a href="#section-5.3">5.3. Audio Latency</a><br/>
    </div>
  <a href="#section-6">6. Developer Tool Compatibility</a><br/>
  <a href="#section-7">7. Hardware Compatibility</a><br/>
  <div style="margin-left: 2em;">
    <a href="#section-7.1">7.1. Display and Graphics</a><br/>
    <div style="margin-left: 2em;">
      <a href="#section-7.1.1">7.1.1. Screen Configurations</a><br/>
      <a href="#section-7.1.2">7.1.2. Display Metrics</a><br/>
      <a href="#section-7.1.3">7.1.3. Declared Screen Support</a><br/>
      <a href="#section-7.1.4">7.1.4. Screen Orientation</a><br/>
      <a href="#section-7.1.5">7.1.5. 3D Graphics Accleration</a><br/>
    </div>
    <a href="#section-7.2">7.2. Input Devices</a><br/>
    <div style="margin-left: 2em;">
      <a href="#section-7.2.1">7.2.1. Keyboard</a><br/>
      <a href="#section-7.2.2">7.2.2. Non-touch Navigation</a><br/>
      <a href="#section-7.2.3">7.2.3. Navigation keys</a><br/>
      <a href="#section-7.2.4">7.2.4. Touchscreen input</a><br/>
    </div>
    <a href="#section-7.3">7.3. Sensors</a><br/>
    <div style="margin-left: 2em;">
      <a href="#section-7.3.1">7.3.1. Accelerometer</a><br/>
      <a href="#section-7.3.2">7.3.2. Magnetometer</a><br/>
      <a href="#section-7.3.3">7.3.3. GPS</a><br/>
      <a href="#section-7.3.4">7.3.4. Gyroscope</a><br/>
      <a href="#section-7.3.5">7.3.5. Barometer</a><br/>
      <a href="#section-7.3.6">7.3.6. Thermometer</a><br/>
      <a href="#section-7.3.7">7.3.7. Photometer</a><br/>
      <a href="#section-7.3.8">7.3.8. Proximity Sensor</a><br/>
    </div>
    <a href="#section-7.4">7.4. Data Connectivity</a><br/>
    <div style="margin-left: 2em;">
      <a href="#section-7.4.1">7.4.1. Telephony</a><br/>
      <a href="#section-7.4.2">7.4.2. IEEE 802.11 (WiFi)</a><br/>
      <a href="#section-7.4.3">7.4.3. Bluetooth</a><br/>
      <a href="#section-7.4.4">7.4.4. Near-Field Communications</a><br/>
      <a href="#section-7.4.5">7.4.5. Minimum Network Capability</a><br/>
    </div>
    <a href="#section-7.5">7.5. Cameras</a><br/>
    <div style="margin-left: 2em;">
      <a href="#section-7.5.1">7.5.1. Rear-Facing Camera</a><br/>
      <a href="#section-7.5.2">7.5.2. Front-Facing Camera</a><br/>
      <a href="#section-7.5.3">7.5.3. Camera API Behavior</a><br/>
      <a href="#section-7.5.4">7.5.4. Camera Orientation</a><br/>
    </div>
    <a href="#section-7.6">7.6. Memory and Storage</a><br/>
    <div style="margin-left: 2em;">
      <a href="#section-7.6.1">7.6.1. Minimum Memory and Storage</a><br/>
      <a href="#section-7.6.2">7.6.2. Application Shared Storage</a><br/>
    </div>
    <a href="#section-7.7">7.7. USB</a><br/>
  </div>
  <a href="#section-8">8. Performance Compatibility</a><br/>
  <a href="#section-9">9. Security Model Compatibility</a><br/>
  <div style="margin-left: 2em;">
    <a href="#section-9.1">9.1. Permissions</a><br/>
    <a href="#section-9.2">9.2. UID and Process Isolation</a><br/>
    <a href="#section-9.3">9.3. Filesystem Permissions</a><br/>
    <a href="#section-9.4">9.4. Alternate Execution Environments</a><br/>
  </div>
  <a href="#section-10">10. Software Compatibility Testing</a><br/>
  <div style="margin-left: 2em;">
    <a href="#section-10.1">10.1. Compatibility Test Suite</a><br/>
    <a href="#section-10.2">10.2. CTS Verifier</a><br/>
    <a href="#section-10.3">10.3. Reference Applications</a><br/>
  </div>
  <a href="#section-11">11. Updatable Software</a><br/>
  <a href="#section-12">12. Contact Us</a><br/>
  <a href="#appendix-A">Appendix A - Bluetooth Test Procedure</a><br/>
</div>

<div style="page-break-before: always;"></div>

<a name="section-1"></a><h2>1. Introduction</h2>
<p>This document enumerates the requirements that must be met in order for
mobile phones to be compatible with Android 2.3.</p>
<p>The use of "must", "must not", "required", "shall", "shall not", "should",
"should not", "recommended", "may" and "optional" is per the IETF standard
defined in RFC2119 [<a href="#resources01">Resources, 1</a>].</p>
<p>As used in this document, a "device implementer" or "implementer" is a
person or organization developing a hardware/software solution running Android
2.3. A "device implementation" or "implementation" is the hardware/software
solution so developed.</p>
<p>To be considered compatible with Android 2.3, device implementations
MUST meet the requirements presented in this Compatibility Definition,
including any documents incorporated via reference.</p>
<p>Where this definition or the software tests described in <a
href="#section-10">Section 10</a> is silent, ambiguous, or incomplete, it is
the responsibility of the device implementer to ensure compatibility with
existing implementations. For this reason, the Android Open Source Project [<a
href="#resources03">Resources, 3</a>] is both the reference and preferred
implementation of Android. Device implementers are strongly encouraged to base
their implementations to the greatest extent possible on the "upstream" source
code available from the Android Open Source Project. While some components can
hypothetically be replaced with alternate implementations this practice is
strongly discouraged, as passing the software tests will become substantially
more difficult. It is the implementer's responsibility to ensure full
behavioral compatibility with the standard Android implementation, including
and beyond the Compatibility Test Suite. Finally, note that certain component
substitutions and modifications are explicitly forbidden by this document.</p> 
<p>Please note that this Compatibility Definition is issued to correspond with
the 2.3.3 update to Android, which is API level 10. This Definition obsoletes
and replaces the Compatibility Definition for Android 2.3 versions prior to
2.3.3. (That is, versions 2.3.1 and 2.3.2 are obsolete.) Future
Android-compatible devices running Android 2.3 MUST ship with version 2.3.3 or
later.</p>
<a name="section-2"></a><h2>2. Resources</h2>
<ol>
<a name="resources01"></a><li>IETF RFC2119 Requirement Levels: <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a></li>
<a name="resources02"></a><li>Android Compatibility Program Overview: <a href="http://source.android.com/compatibility/index.html">http://source.android.com/compatibility/index.html</a></li>
<a name="resources03"></a><li>Android Open Source Project: <a href="http://source.android.com/">http://source.android.com/</a></li>
<a name="resources04"></a><li>API definitions and documentation: <a href="http://developer.android.com/reference/packages.html">http://developer.android.com/reference/packages.html</a></li>
<a name="resources05"></a><li>Android Permissions reference: <a href="http://developer.android.com/reference/android/Manifest.permission.html">http://developer.android.com/reference/android/Manifest.permission.html</a></li>
<a name="resources06"></a><li>android.os.Build reference: <a href="http://developer.android.com/reference/android/os/Build.html">http://developer.android.com/reference/android/os/Build.html</a></li>
<a name="resources07"></a><li>Android 2.3 allowed version strings: <a href="http://source.android.com/compatibility/2.3/versions.html">http://source.android.com/compatibility/2.3/versions.html</a></li>
<a name="resources08"></a><li>android.webkit.WebView class: <a href="http://developer.android.com/reference/android/webkit/WebView.html">http://developer.android.com/reference/android/webkit/WebView.html</a></li>
<a name="resources09"></a><li>HTML5: <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">http://www.whatwg.org/specs/web-apps/current-work/multipage/</a></li>
<a name="resources10"></a><li>HTML5 offline capabilities: <a href="http://dev.w3.org/html5/spec/Overview.html#offline">http://dev.w3.org/html5/spec/Overview.html#offline</a></li>
<a name="resources11"></a><li>HTML5 video tag: <a href="http://dev.w3.org/html5/spec/Overview.html#video">http://dev.w3.org/html5/spec/Overview.html#video</a></li>
<a name="resources12"></a><li>HTML5/W3C geolocation API: <a href="http://www.w3.org/TR/geolocation-API/">http://www.w3.org/TR/geolocation-API/</a></li>
<a name="resources13"></a><li>HTML5/W3C webdatabase API: <a href="http://www.w3.org/TR/webdatabase/">http://www.w3.org/TR/webdatabase/</a></li>
<a name="resources14"></a><li>HTML5/W3C IndexedDB API: <a href="http://www.w3.org/TR/IndexedDB/">http://www.w3.org/TR/IndexedDB/</a></li>
<a name="resources15"></a><li>Dalvik Virtual Machine specification: available in the Android source code, at dalvik/docs</li>
<a name="resources16"></a><li>AppWidgets: <a href="http://developer.android.com/guide/practices/ui_guidelines/widget_design.html">http://developer.android.com/guide/practices/ui_guidelines/widget_design.html</a></li>
<a name="resources17"></a><li>Notifications: <a href="http://developer.android.com/guide/topics/ui/notifiers/notifications.html">http://developer.android.com/guide/topics/ui/notifiers/notifications.html</a></li>
<a name="resources18"></a><li>Application Resources: <a href="http://code.google.com/android/reference/available-resources.html">http://code.google.com/android/reference/available-resources.html</a></li>
<a name="resources19"></a><li>Status Bar icon style guide: <a href="http://developer.android.com/guide/practices/ui_guidelines/icon_design.html#statusbarstructure">http://developer.android.com/guide/practices/ui_guideline /icon_design.html#statusbarstructure</a></li>
<a name="resources20"></a><li>Search Manager: <a href="http://developer.android.com/reference/android/app/SearchManager.html">http://developer.android.com/reference/android/app/SearchManager.html</a></li>
<a name="resources21"></a><li>Toasts: <a href="http://developer.android.com/reference/android/widget/Toast.html">http://developer.android.com/reference/android/widget/Toast.html</a></li>
<a name="resources22"></a><li>Live Wallpapers: <a href="http://developer.android.com/resources/articles/live-wallpapers.html">http://developer.android.com/resources/articles/live-wallpapers.html</a></li>
<a name="resources23"></a><li>Reference tool documentation (for adb, aapt, ddms): <a href="http://developer.android.com/guide/developing/tools/index.html">http://developer.android.com/guide/developing/tools/index.html</a></li>
<a name="resources24"></a><li>Android apk file description: <a href="http://developer.android.com/guide/topics/fundamentals.html">http://developer.android.com/guide/topics/fundamentals.html</a></li>
<a name="resources25"></a><li>Manifest files: <a href="http://developer.android.com/guide/topics/manifest/manifest-intro.html">http://developer.android.com/guide/topics/manifest/manifest-intro.html</a></li>
<a name="resources26"></a><li>Monkey testing tool: <a href="http://developer.android.com/guide/developing/tools/monkey.html">http://developer.android.com/guide/developing/tools/monkey.html</a></li>
<a name="resources27"></a><li>Android Hardware Features List: <a href="http://developer.android.com/reference/android/content/pm/PackageManager.html">http://developer.android.com/reference/android/content/pm/PackageManager.html</a></li>
<a name="resources28"></a><li>Supporting Multiple Screens: <a href="http://developer.android.com/guide/practices/screens_support.html">http://developer.android.com/guide/practices/screens_support.html</a></li>
<a name="resources29"></a><li>android.util.DisplayMetrics: <a href="http://developer.android.com/reference/android/util/DisplayMetrics.html">http://developer.android.com/reference/android/util/DisplayMetrics.html</a></li>
<a name="resources30"></a><li>android.content.res.Configuration: <a href="http://developer.android.com/reference/android/content/res/Configuration.html">http://developer.android.com/reference/android/content/res/Configuration.html</a></li>
<a name="resources31"></a><li>Sensor coordinate space: <a href="http://developer.android.com/reference/android/hardware/SensorEvent.html">http://developer.android.com/reference/android/hardware/SensorEvent.html</a></li>
<a name="resources32"></a><li>Bluetooth API: <a href="http://developer.android.com/reference/android/bluetooth/package-summary.html">http://developer.android.com/reference/android/bluetooth/package-summary.html</a></li>
<a name="resources33"></a><li>NDEF Push Protocol: <a href="http://source.android.com/compatibility/ndef-push-protocol.pdf">http://source.android.com/compatibility/ndef-push-protocol.pdf</a></li>
<a name="resources34"></a><li>MIFARE MF1S503X: <a href="http://www.nxp.com/documents/data_sheet/MF1S503x.pdf">http://www.nxp.com/documents/data_sheet/MF1S503x.pdf</a></li>
<a name="resources35"></a><li>MIFARE MF1S703X: <a href="http://www.nxp.com/documents/data_sheet/MF1S703x.pdf">http://www.nxp.com/documents/data_sheet/MF1S703x.pdf</a></li>
<a name="resources36"></a><li>MIFARE MF0ICU1: <a href="http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf">http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf</a></li>
<a name="resources37"></a><li>MIFARE MF0ICU2: <a href="http://www.nxp.com/documents/short_data_sheet/MF0ICU2_SDS.pdf">http://www.nxp.com/documents/short_data_sheet/MF0ICU2_SDS.pdf</a></li>
<a name="resources38"></a><li>MIFARE AN130511: <a href="http://www.nxp.com/documents/application_note/AN130511.pdf">http://www.nxp.com/documents/application_note/AN130511.pdf</a></li>
<a name="resources39"></a><li>MIFARE AN130411: <a href="http://www.nxp.com/documents/application_note/AN130411.pdf">http://www.nxp.com/documents/application_note/AN130411.pdf</a></li>
<a name="resources40"></a><li>Camera orientation API: <a href="http://developer.android.com/reference/android/hardware/Camera.html#setDisplayOrientation(int)">http://developer.android.com/reference/android/hardware/Camera.html#setDisplayOrientation(int)</a></li>
<a name="resources41"></a><li>android.hardware.Camera: <a href="http://developer.android.com/reference/android/hardware/Camera.html">http://developer.android.com/reference/android/hardware/Camera.html</a></li>
<a name="resources42"></a><li>Android Security and Permissions reference: <a href="http://developer.android.com/guide/topics/security/security.html">http://developer.android.com/guide/topics/security/security.html</a></li>
<a name="resources43"></a><li>Apps for Android: <a href="http://code.google.com/p/apps-for-android">http://code.google.com/p/apps-for-android</a></li>
</ol>
<p>Many of these resources are derived directly or indirectly from the Android
2.3 SDK, and will be functionally identical to the information in that SDK's
documentation. In any cases where this Compatibility Definition or the
Compatibility Test Suite disagrees with the SDK documentation, the SDK
documentation is considered authoritative. Any technical details provided in
the references included above are considered by inclusion to be part of this
Compatibility Definition.</p>

<a name="section-3"></a><h2>3. Software</h2>
<p>The Android platform includes a set of managed APIs, a set of native APIs,
and a body of so-called "soft" APIs such as the Intent system and
web-application APIs. This section details the hard and soft APIs that are
integral to compatibility, as well as certain other relevant technical and
user interface behaviors. Device implementations MUST comply with all the
requirements in this section.</p>

<a name="section-3.1"></a><h3>3.1. Managed API Compatibility</h3>
<p>The managed (Dalvik-based) execution environment is the primary vehicle for
Android applications. The Android application programming interface (API) is
the set of Android platform interfaces exposed to applications running in the
managed VM environment. Device implementations MUST provide complete
implementations, including all documented behaviors, of any documented API
exposed by the Android 2.3 SDK [<a href="#resources04">Resources, 4</a>].</p>
<p>Device implementations MUST NOT omit any managed APIs, alter API interfaces
or signatures, deviate from the documented behavior, or include no-ops, except
where specifically allowed by this Compatibility Definition.</p>
<p>This Compatibility Definition permits some types of hardware for which
Android includes APIs to be omitted by device implementations. In such cases,
the APIs MUST still be present and behave in a reasonable way. See Section 7
for specific requirements for this scenario.</p>

<a name="section-3.2"></a><h3>3.2. Soft API Compatibility</h3>
<p>In addition to the managed APIs from Section 3.1, Android also includes a
significant runtime-only "soft" API, in the form of such things such as
Intents, permissions, and similar aspects of Android applications that cannot
be enforced at application compile time. This section details the "soft" APIs
and system behaviors required for compatibility with Android 2.3. Device
implementations MUST meet all the requirements presented in this section.</p>
<a name="section-3.2.1"></a><h4>3.2.1. Permissions</h4>
<p>Device implementers MUST support and enforce all permission constants as
documented by the Permission reference page [<a
href="#resources05">Resources, 5</a>]. Note that Section 10 lists additional
requirements related to the Android security model.</p>
<a name="section-3.2.3"></a><h4>3.2.2. Build Parameters</h4>
<p>The Android APIs include a number of constants on the <code>android.os.Build</code>
class [<a href="#resources06">Resources, 6</a>] that are intended to describe
the current device. To provide consistent, meaningful values across device
implementations, the table below includes additional restrictions on the
formats of these values to which device implementations MUST conform.</p>
<table>
<tbody>
<tr>
<td><b>Parameter</b></td>
<td><b>Comments</b></td>
</tr>
<tr>
<td>android.os.Build.VERSION.RELEASE</td>
<td>The version of the currently-executing Android system, in human-readable
format. This field MUST have one of the string values defined in [<a
href="#resources07">Resources, 7</a>].</td>
</tr>
<tr>
<td>android.os.Build.VERSION.SDK</td>
<td>The version of the currently-executing Android system, in a format
accessible to third-party application code. For Android 2.3, this field MUST have
the integer value 9.</td>
</tr>
<tr>
<td>android.os.Build.VERSION.INCREMENTAL</td>
<td>A value chosen by the device implementer designating the specific build of
the currently-executing Android system, in human-readable format. This value
MUST NOT be re-used for different builds made available to end users. A typical use
of this field is to indicate which build number or source-control change
identifier was used to generate the build. There are no requirements on the
specific format of this field, except that it MUST NOT be null or the empty
string ("").</td>
</tr>
<tr>
<td>android.os.Build.BOARD</td>
<td>A value chosen by the device implementer identifying the specific internal
hardware used by the device, in human-readable format. A possible use of this
field is to indicate the specific revision of the board powering the device.
The value of this field MUST be encodable as 7-bit ASCII and match the regular expression
<code>"^[a-zA-Z0-9.,_-]+$"</code>.</td>
</tr>
<tr>
<td>android.os.Build.BRAND</td>
<td>A value chosen by the device implementer identifying the name of the
company, organization, individual, etc. who produced the device, in
human-readable format. A possible use of this field is to indicate the OEM
and/or carrier who sold the device. The value of this field MUST be
encodable as 7-bit ASCII and match the regular expression
<code>"^[a-zA-Z0-9.,_-]+$"</code>.
</td>
</tr>
<tr>
<td>android.os.Build.DEVICE</td>
<td>A value chosen by the device implementer identifying the specific
configuration or revision of the body (sometimes called "industrial design")
of the device. The value of this field MUST be encodable as 7-bit ASCII and
match the regular expression <code>"^[a-zA-Z0-9.,_-]+$"</code>.</td>
</tr>
<tr>
<td>android.os.Build.FINGERPRINT</td>
<td>A string that uniquely identifies this build. It SHOULD be reasonably
human-readable. It MUST follow this template:
<br/><code>$(BRAND)/$(PRODUCT)/$(DEVICE):$(VERSION.RELEASE)/$(ID)/$(VERSION.INCREMENTAL):$(TYPE)/$(TAGS)</code><br/>
For example:
<br/><code>acme/mydevice/generic/generic:2.3/ERC77/3359:userdebug/test-keys</code><br/>
The fingerprint MUST NOT include whitespace characters. If other fields included in the
template above have whitespace characters, they MUST be replaced in the build
fingerprint with another character, such as the underscore ("_") character.
The value of this field MUST be encodable as 7-bit ASCII.</td>
</tr>
<tr>
<td>android.os.Build.HOST</td>
<td>A string that uniquely identifies the host the build was built on, in
human readable format. There are no requirements on the specific format of
this field, except that it MUST NOT be null or the empty string ("").</td>
</tr>
<tr>
<td>android.os.Build.ID</td>
<td>An identifier chosen by the device implementer to refer to a specific
release, in human readable format. This field can be the same as
android.os.Build.VERSION.INCREMENTAL, but SHOULD be a value sufficiently
meaningful for end users to distinguish between software builds. The value of
this field MUST be encodable as 7-bit ASCII and match the regular expression
<code>"^[a-zA-Z0-9.,_-]+$"</code>.
</td>
</tr>
<tr>
<td>android.os.Build.MODEL</td>
<td>A value chosen by the device implementer containing the name of the device
as known to the end user. This SHOULD be the same name under which the device
is marketed and sold to end users. There are no requirements on the specific
format of this field, except that it MUST NOT be null or the empty string
("").</td>
</tr>
<tr>
<td>android.os.Build.PRODUCT</td>
<td>A value chosen by the device implementer containing the development name
or code name of the device. MUST be human-readable, but is not necessarily
intended for view by end users. The value of this field MUST be
encodable as 7-bit ASCII and match the regular expression
<code>"^[a-zA-Z0-9.,_-]+$"</code>.</td>
</tr>
<tr>
<td>android.os.Build.TAGS</td>
<td>A comma-separated list of tags chosen by the device implementer that
further distinguish the build. For example, "unsigned,debug". The value of
this field MUST be encodable as 7-bit ASCII and match the regular expression
<code>"^[a-zA-Z0-9.,_-]+$"</code>.</td>
</tr>
<tr>
<td>android.os.Build.TIME</td>
<td>A value representing the timestamp of when the build occurred.</td>
</tr>
<tr>
<td>android.os.Build.TYPE</td>
<td>A value chosen by the device implementer specifying the runtime
configuration of the build. This field SHOULD have one of the values
corresponding to the three typical Android runtime configurations: "user",
"userdebug", or "eng". The value of this field MUST be
encodable as 7-bit ASCII and match the regular expression
<code>"^[a-zA-Z0-9.,_-]+$"</code>.</td>
</tr>
<tr>
<td>android.os.Build.USER</td>
<td>A name or user ID of the user (or automated user) that generated the
build. There are no requirements on the specific format of this field, except
that it MUST NOT be null or the empty string ("").</td>
</tr>
</tbody>
</table>
<a name="section-3.2.3"></a><h4>3.2.3. Intent Compatibility</h4>
<p>Android uses Intents to achieve loosely-coupled integration between
applications. This section describes requirements related to the Intent
patterns that MUST be honored by device implementations. By "honored", it is
meant that the device implementer MUST provide an Android Activity or Service
that specifies a matching Intent filter and binds to and implements correct
behavior for each specified Intent pattern.</p>
<a name="section-3.2.3.1"></a><h4>3.2.3.1. Core Application Intents</h4>
<p>The Android upstream project defines a number of core applications, such as
a phone dialer, calendar, contacts book, music player, and so on. Device
implementers MAY replace these applications with alternative versions.</p>
<p>However, any such alternative versions MUST honor the same Intent patterns
provided by the upstream project. For example, if a device contains an
alternative music player, it must still honor the Intent pattern issued by
third-party applications to pick a song.</p>
<p>The following applications are considered core Android system
applications:</p>
<ul>
<li>Desk Clock</li>
<li>Browser</li>
<li>Calendar</li>
<li>Calculator</li>
<!-- <li>Camera</li> -->
<li>Contacts</li>
<li>Email</li>
<li>Gallery</li>
<li>GlobalSearch</li>
<li>Launcher</li>
<!-- <li>LivePicker (that is, the Live Wallpaper picker application; MAY be omitted
if the device does not support Live Wallpapers, per Section 3.8.5.)</li> -->
<!-- <li>Messaging (AKA "Mms")</li> -->
<li>Music</li>
<!-- <li>Phone</li> -->
<li>Settings</li>
<!-- <li>SoundRecorder</li> -->
</ul>
<p>The core Android system applications include various Activity, or Service
components that are considered "public".  That is, the attribute
"android:exported" may be absent, or may have the value "true".</p>
<p>For every Activity or Service defined
in one of the core Android system apps that is not marked as non-public via an
android:exported attribute with the value "false", device implementations MUST
include a compontent of the same type implementing the same Intent filter
patterns as the core Android system app.</p>
<p>In other words, a device implementation MAY replace core Android system
apps; however, if it does, the device implementation MUST support all Intent
patterns defined by each core Android system app being replaced.</p>
<a name="section-3.2.3.2"></a><h4>3.2.3.2. Intent Overrides</h4>
<p>As Android is an extensible platform, device implementers MUST allow each
Intent pattern referenced in Section 3.2.3.1 to be overridden by third-party
applications. The upstream Android open source project allows this by default;
device implementers MUST NOT attach special privileges to system applications'
use of these Intent patterns, or prevent third-party applications from binding
to and assuming control of these patterns. This prohibition specifically
includes but is not limited to disabling the "Chooser" user interface which
allows the user to select between multiple applications which all handle the
same Intent pattern.</p>
<a name="section-3.2.3.3"></a><h4>3.2.3.3. Intent Namespaces</h4>
<p>Device implementers MUST NOT include any Android component that honors any
new Intent or Broadcast Intent patterns using an ACTION, CATEGORY, or other
key string in the android.* namespace.  Device implementers MUST NOT include
any Android components that honor any new Intent or Broadcast Intent patterns
using an ACTION, CATEGORY, or other key string in a package space belonging to
another organization. Device implementers MUST NOT alter or extend any of the
Intent patterns used by the core apps listed in Section 3.2.3.1.</p>
<p>This prohibition is analogous to that specified for Java language classes
in Section 3.6.</p>
<a name="section-3.2.3.4"></a><h4>3.2.3.4. Broadcast Intents</h4>
<p>Third-party applications rely on the platform to broadcast certain Intents
to notify them of changes in the hardware or software environment.
Android-compatible devices MUST broadcast the public broadcast Intents in
response to appropriate system events. Broadcast Intents are described in the
SDK documentation.</p>

<a name="section-3.3"></a><h3>3.3. Native API Compatibility</h3>
<p>Managed code running in Dalvik can call into native code provided in the
application .apk file as an ELF .so file compiled for the appropriate device
hardware architecture. As native code is highly dependent on the underlying
processor technology, Android defines a number of Application Binary
Interfaces (ABIs) in the Android NDK, in the file
<code>docs/CPU-ARCH-ABIS.txt</code>. If a device implementation is compatible
with one or more defined ABIs, it SHOULD implement compatibility with the
Android NDK, as below.</p>
<p>If a device implementation includes support for an Android ABI, it:</p>
<ul>
<li>MUST include support for code running in the managed environment to call
into native code, using the standard Java Native Interface (JNI)
semantics.</li>
<li>MUST be source-compatible (i.e. header compatible) and binary-compatible
(for the ABI) with each required library in the list below</li>
<li>MUST accurately report the native Application Binary Interface (ABI)
supported by the device, via the <code>android.os.Build.CPU_ABI</code>
API</li>
<li>MUST report only those ABIs documented in the latest version of the
Android NDK, in the file <code>docs/CPU-ARCH-ABIS.txt</code></li>
<li>SHOULD be built using the source code and header files available in the
upstream Android open-source project</li>
</ul>
<p>The following native code APIs MUST be available to apps that include
native code:</p>
<ul>
<li>libc (C library)</li>
<li>libm (math library)</li>
<li>Minimal support for C++</li>
<li>JNI interface</li>
<li>liblog (Android logging)</li>
<li>libz (Zlib compression)</li>
<li>libdl (dynamic linker)</li>
<li>libGLESv1_CM.so (OpenGL ES 1.0)</li>
<li>libGLESv2.so (OpenGL ES 2.0)</li>
<li>libEGL.so (native OpenGL surface management)</li>
<li>libjnigraphics.so</li>
<li>libOpenSLES.so (Open Sound Library audio support)</li>
<li>libandroid.so (native Android activity support)</li>
<li>Support for OpenGL, as described below</li>
</ul>
<p>Note that future releases of the Android NDK may introduce support for
additional ABIs. If a device implementation is not compatible with an existing
predefined ABI, it MUST NOT report support for any ABI at all.</p>
<p>Native code compatibility is challenging. For this reason, it should be
repeated that device implementers are VERY strongly encouraged to use the
upstream implementations of the libraries listed above to help ensure
compatibility.</p>

<a name="section-3.4"></a><h3>3.4. Web Compatibility</h3>
<p>Many developers and applications rely on the behavior of the
<code>android.webkit.WebView</code> class [<a
href="#resources08">Resources, 8</a>]
for their user interfaces, so the WebView implementation must be
compatible across Android implementations. Similarly, a complete, modern web
broswer is central to the Android user experience. Device implementations MUST
include a version of <code>android.webkit.WebView</code> consistent with the
upstream Android software, and MUST include a modern HTML5-capable browser, as
described below.</p>
<a name="section-3.4.1"></a><h4>3.4.1. WebView Compatibility</h4>
<p>The Android Open Source implementation uses the WebKit rendering engine to
implement the <code>android.webkit.WebView</code>. Because it is not feasible
to develop a comprehensive test suite for a web rendering system, device
implementers MUST use the specific upstream build of WebKit in the WebView
implementation.  Specifically:</p>
<ul>
<li>Device implementations' <code>android.webkit.WebView</code>
implementations MUST be based on the 533.1 WebKit build from the upstream
Android Open Source tree for Android 2.3. This build includes a specific set
of functionality and security fixes for the WebView. Device implementers MAY
include customizations to the WebKit implementation; however, any such
customizations MUST NOT alter the behavior of the WebView, including rendering
behavior.</li>
<li>The user agent string reported by the WebView MUST be in this format:<br/>
    <code>Mozilla/5.0 (Linux; U; Android $(VERSION); $(LOCALE); $(MODEL) Build/$(BUILD)) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1</code>
  <ul>
  <li>The value of the $(VERSION) string MUST be the same as the value for <code>android.os.Build.VERSION.RELEASE</code></li>
  <li>The value of the $(LOCALE) string SHOULD follow the ISO conventions for country code and language, and SHOULD refer to the current configured locale of the device</li>
  <li>The value of the $(MODEL) string MUST be the same as the value for <code>android.os.Build.MODEL</code></li>
  <li>The value of the $(BUILD) string MUST be the same as the value for <code>android.os.Build.ID</code></li>
  </ul></li>
</ul>
<p>The WebView component SHOULD include support for as much of HTML5 [<a
href="#resources09">Resources, 9</a>] as possible.
Minimally, device implementations MUST support each of these APIs associated
with HTML5 in the WebView:</p>
<ul>
<li>application cache/offline operation [<a href="#resources10">Resources, 10</a>]</li>
<li>the &lt;video&gt; tag [<a href="#resources11">Resources, 11</a>]</li>
<li>geolocation [<a href="#resources12">Resources, 12</a>]</li>
</ul>
<p>Additionally, device implementations MUST support the HTML5/W3C webstorage
API [<a href="#resources13">Resources, 13</a>], and SHOULD support the
HTML5/W3C IndexedDB API [<a href="#resources14">Resources, 14</a>]. <i>Note
that as the web development standards bodies are transitioning to favor
IndexedDB over webstorage, IndexedDB is expected to become a required
component in a future version of Android.</i></p>
<p>HTML5 APIs, like all JavaScript APIs, MUST be disabled by default in a
WebView, unless the developer explicitly enables them via the usual Android
APIs.</p>

<a name="section-3.4.2"></a><h4>3.4.2. Browser Compatibility</h4>
<p>Device implementations MUST include a standalone Browser application for
general user web browsing. The standalone Browser MAY be based on a
browser technology other than WebKit. However, even if an alternate Browser
application is used, the <code>android.webkit.WebView</code> component
provided to third-party applications MUST be based on WebKit, as described in
Section 3.4.1.</p>
<p>Implementations MAY ship a custom user agent string in the standalone
Browser application.</p>
<p>The standalone Browser application (whether based on the upstream
WebKit Browser application or a third-party replacement) SHOULD include support
for as much of HTML5 [<a href="#resources09">Resources, 9</a>] as possible.
Minimally, device implementations MUST support each of these APIs associated
with HTML5:</p>
<ul>
<li>application cache/offline operation [<a href="#resources10">Resources, 10</a>]</li>
<li>the &lt;video&gt; tag [<a href="#resources11">Resources, 11</a>]</li>
<li>geolocation [<a href="#resources12">Resources, 12</a>]</li>
</ul>
<p>Additionally, device implementations MUST support the HTML5/W3C webstorage
API [<a href="#resources13">Resources, 13</a>], and SHOULD support the
HTML5/W3C IndexedDB API [<a href="#resources14">Resources, 14</a>]. <i>Note
that as the web development standards bodies are transitioning to favor
IndexedDB over webstorage, IndexedDB is expected to become a required
component in a future version of Android.</i></p>

<a name="section-3.5"></a><h3>3.5. API Behavioral Compatibility</h3>
<p>The behaviors of each of the API types (managed, soft, native, and web)
must be consistent with the preferred implementation of the upstream Android
open-source project [<a href="#resources03">Resources, 3</a>]. Some specific areas
of compatibility are:</p>
<ul>
<li>Devices MUST NOT change the behavior or semantics of a standard Intent</li>
<li>Devices MUST NOT alter the lifecycle or lifecycle semantics of a
    particular type of system component (such as Service, Activity,
    ContentProvider, etc.)</li>
<li>Devices MUST NOT change the semantics of a standard permission</li>
</ul>
<p>The above list is not comprehensive. The Compatibility Test Suite (CTS)
tests significant portions of the platform for behavioral compatibility, but
not all. It is the responsibility of the implementer to ensure behavioral
compatibility with the Android Open Source Project.  For this reason, device
implementers SHOULD use the source code available via the Android Open Source
Project where possible, rather than re-implement significant parts of the
system.</p>


<a name="section-3.6"></a><h3>3.6. API Namespaces</h3>
<p>Android follows the package and class namespace conventions defined by the
Java programming language. To ensure compatibility with third-party
applications, device implementers MUST NOT make any prohibited modifications
(see below) to these package namespaces:</p>
<ul>
<li>java.*</li>
<li>javax.*</li>
<li>sun.*</li>
<li>android.*</li>
<li>com.android.*</li>
</ul>
<p>Prohibited modifications include:</p>
<ul>
<li>Device implementations MUST NOT modify the publicly exposed APIs on the
Android platform by changing any method or class signatures, or by removing
classes or class fields.</li>
<li>Device implementers MAY modify the underlying implementation of the APIs,
but such modifications MUST NOT impact the stated behavior and Java-language
signature of any publicly exposed APIs.</li>
<li>Device implementers MUST NOT add any publicly exposed elements (such as
classes or interfaces, or fields or methods to existing classes or interfaces)
to the APIs above.</li>
</ul>
<p>A "publicly exposed element" is any construct which is not decorated with
the "@hide" marker as used in the upstream Android source code. In other
words, device implementers MUST NOT expose new APIs or alter existing APIs in
the namespaces noted above. Device implementers MAY make internal-only
modifications, but those modifications MUST NOT be advertised or otherwise
exposed to developers.</p>
<p>Device implementers MAY add custom APIs, but any such APIs MUST NOT be in a
namespace owned by or referring to another organization. For instance, device
implementers MUST NOT add APIs to the com.google.* or similar namespace; only
Google may do so. Similarly, Google MUST NOT add APIs to other companies'
namespaces. Additionally, if a device implementation includes custom APIs
outside the standard Android namespace, those APIs MUST be packaged in an
Android shared library so that only apps that explicitly use them (via the
<code>&lt;uses-library&gt;</code> mechanism) are affected by the increased
memory usage of such APIs.</p>
<p>If a device implementer proposes to improve one of the package namespaces
above (such as by adding useful new functionality to an existing API, or
adding a new API), the implementer SHOULD visit source.android.com and begin
the process for contributing changes and code, according to the information on
that site.</p>
<p>Note that the restrictions above correspond to standard conventions for
naming APIs in the Java programming language; this section simply aims to
reinforce those conventions and make them binding through inclusion in this
compatibility definition.</p>

<a name="section-3.7"></a><h3>3.7. Virtual Machine Compatibility</h3>
<p>Device implementations MUST support the full Dalvik Executable (DEX)
bytecode specification and Dalvik Virtual Machine semantics [<a
href="#resources15">Resources, 15</a>].</p>
<p>Device implementations with screens classified as medium- or low-density
MUST configure Dalvik to allocate at least 16MB of memory to each application.
Device implementations with screens classified as high-density or
extra-high-density MUST configure Dalvik to allocate at least 24MB of memory
to each application. Note that device implementations MAY allocate more memory
than these figures.</p>

<a name="section-3.8"></a><h3>3.8. User Interface Compatibility</h3>
<p>The Android platform includes some developer APIs that allow developers to
hook into the system user interface. Device implementations MUST incorporate
these standard UI APIs into custom user interfaces they develop, as explained
below.</p>
<a name="section-3.8.1"></a><h4>3.8.1. Widgets</h4>
<p>Android defines a component type and corresponding API and lifecycle that
allows applications to expose an "AppWidget" to the end user [<a
href="#resources16">Resources, 16</a>].
The Android Open Source reference release includes a Launcher application that
includes user interface elements allowing the user to add, view, and remove
AppWidgets from the home screen.</p>
<p>Device implementers MAY substitute an alternative to the reference Launcher
(i.e. home screen).  Alternative Launchers SHOULD include built-in support for
AppWidgets, and expose user interface elements to add, configure, view, and remove
AppWidgets directly within the Launcher. Alternative Launchers MAY omit these
user interface elements; however, if they are omitted, the device implementer
MUST provide a separate application accessible from the Launcher that allows
users to add, configure, view, and remove AppWidgets.</p>
<a name="section-3.8.2"></a><h4>3.8.2. Notifications</h4>
<p>Android includes APIs that allow developers to notify users of notable
events [<a href="#resources17">Resources, 17</a>]. Device implementers MUST provide support for each
class of notification so defined; specifically: sounds, vibration, light and
status bar.</p>
<p>Additionally, the implementation MUST correctly render all resources
(icons, sound files, etc.) provided for in the APIs [<a
href="#resources18">Resources, 18</a>], or in the
Status Bar icon style guide [<a href="#resources19">Resources, 19</a>]. Device implementers MAY provide
an alternative user experience for notifications than that provided by the
reference Android Open Source implementation; however, such alternative
notification systems MUST support existing notification resources, as
above.</p>
<a name="section-3.8.3"></a><h4>3.8.3. Search</h4>
<p>Android includes APIs [<a href="#resources20">Resources, 20</a>] that allow developers to incorporate
search into their applications, and expose their application's data into the
global system search. Generally speaking, this functionality consists of a
single, system-wide user interface that allows users to enter queries,
displays suggestions as users type, and displays results. The Android APIs
allow developers to reuse this interface to provide search within their own
apps, and allow developers to supply results to the common global search user
interface.</p>
<p>Device implementations MUST include a single, shared, system-wide search
user interface capable of real-time suggestions in response to user input.
Device implementations MUST implement the APIs that allow developers to reuse
this user interface to provide search within their own applications.  Device
implementations MUST implement the APIs that allow third-party applications to
add suggestions to the search box when it is run in global search mode. If no
third-party applications are installed that make use of this functionality,
the default behavior SHOULD be to display web search engine results and
suggestions.</p>
<p>Device implementations MAY ship alternate search user interfaces, but
SHOULD include a hard or soft dedicated search button, that can be used at any
time within any app to invoke the search framework, with the behavior provided
for in the API documentation.</p>
<a name="section-3.8.4"></a><h4>3.8.4. Toasts</h4>
<p>Applications can use the "Toast" API (defined in [<a
href="#resources21">Resources, 21</a>]) to
display short non-modal strings to the end user, that disappear after a brief
period of time. Device implementations MUST display Toasts from applications
to end users in some high-visibility manner.</p>
<a name="section-3.8.5"></a><h4>3.8.5. Live Wallpapers</h4>
<p>Android defines a component type and corresponding API and lifecycle that
allows applications to expose one or more "Live Wallpapers" to the end user
[<a href="#resources22">Resources, 22</a>]. Live Wallpapers are animations,
patterns, or similar images with limited input capabilities that display as a
wallpaper, behind other applications.</p>
<p>Hardware is considered capable of reliably running live wallpapers if it
can run all live wallpapers, with no limitations on functionality, at a
reasonable framerate with no adverse affects on other applications. If
limitations in the hardware cause wallpapers and/or applications to crash,
malfunction, consume excessive CPU or battery power, or run at unacceptably
low frame rates, the hardware is considered incapable of running live
wallpaper. As an example, some live wallpapers may use an Open GL 1.0 or 2.0
context to render their content. Live wallpaper will not run reliably on
hardware that does not support multiple OpenGL contexts because the live
wallpaper use of an OpenGL context may conflict with other applications that
also use an OpenGL context.</p>
<p>Device implementations capable of running live wallpapers reliably as
described above SHOULD implement live wallpapers. Device implementations
determined to not run live wallpapers reliably as described above MUST NOT
implement live wallpapers.</p>

<a name="section-4"></a><h2>4. Application Packaging Compatibility</h2>
<p>Device implementations MUST install and run Android ".apk" files as
generated by the "aapt" tool included in the official Android SDK [<a
href="#resources23">Resources, 23</a>].</p>
<p>Devices implementations MUST NOT extend either the .apk [<a
href="#resources24">Resources, 24</a>], Android Manifest [<a
href="#resources25">Resources, 25</a>],
or Dalvik bytecode [<a href="#resources15">Resources, 15</a>] formats in such
a way that would prevent those files from
installing and running correctly on other compatible devices. Device
implementers SHOULD use the reference upstream implementation of Dalvik, and
the reference implementation's package management system.</p>

<a name="section-5"></a><h2>5. Multimedia Compatibility</h2>
<p>Device implementations MUST fully implement all multimedia APIs. Device
implementations MUST include support for all multimedia codecs described
below, and SHOULD meet the sound processing guidelines described below. Device
implementations MUST include at least one form of audio output, such as
speakers, headphone jack, external speaker connection, etc.</p>
<a name="section-5.1"></a><h3>5.1. Media Codecs</h3>
<p>Device implementations MUST support the multimedia codecs as detailed in
the following sections. All of these codecs are provided as software
implementations in the preferred Android implementation from the Android
Open-Source Project.</p>
<p>Please note that neither Google nor the Open Handset Alliance make any
representation that these codecs are unencumbered by third-party patents.
Those intending to use this source code in hardware or software products are
advised that implementations of this code, including in open source software
or shareware, may require patent licenses from the relevant patent
holders.</p>
<p>The tables below do not list specific bitrate requirements for
most video codecs. The reason for this is that in practice, current device
hardware does not necessarily support bitrates that map exactly to the
required bitrates specified by the relevant standards. Instead, device
implementations SHOULD support the highest bitrate practical on the hardware,
up to the limits defined by the specifications.</p>
<a name="section-5.1.1"></a><h3>5.1.1. Media Decoders</h3>
<p>Device implementations MUST include an implementation of an decoder for
each codec and format described in the table below. Note that decoders for
each of these media types are provided by the upstream Android Open-Source
Project.</p>
<table><tbody>
<tr>
<td rowspan="11"><b>Audio</b></td>
</tr>
<tr>
<td><b>Name</b></td>
<td><b>Details</b></td>
<td><b>File/Container Format</b></td>
</tr>
<tr>
<td>AAC LC/LTP</td>
<td rowspan="3">Mono/Stereo content in any combination of standard bit rates up to 160 kbps and sampling rates between 8 to 48kHz</td>
<td rowspan="3">3GPP (.3gp) and MPEG-4 (.mp4, .m4a). No support for raw AAC (.aac)</td>
</tr>
<tr>
<td>HE-AACv1 (AAC+)</td>
</tr>
<tr>
<td>HE-AACv2 (enhanced AAC+)</td>
</tr>
<tr>
<td>AMR-NB</td>
<td>4.75 to 12.2 kbps sampled @ 8kHz</td>
<td>3GPP (.3gp)</td>
</tr>
<tr>
<td>AMR-WB</td>
<td>9 rates from 6.60 kbit/s to 23.85 kbit/s sampled @ 16kHz</td>
<td>3GPP (.3gp)</td>
</tr>
<tr>
<td>MP3</td>
<td>Mono/Stereo 8-320Kbps constant (CBR) or variable bit-rate (VBR)</td>
<td>MP3 (.mp3)</td>
</tr>
<tr>
<td>MIDI</td>
<td>MIDI Type 0 and 1. DLS Version 1 and 2. XMF and Mobile XMF. Support for ringtone formats RTTTL/RTX, OTA, and iMelody</td>
<td>Type 0 and 1 (.mid, .xmf, .mxmf). Also RTTTL/RTX (.rtttl, .rtx), OTA (.ota), and iMelody (.imy)</td>
</tr>
<tr>
<td>Ogg Vorbis</td>
<td>&nbsp;</td>
<td>Ogg (.ogg)</td>
</tr>
<tr>
<td>PCM</td>
<td>8- and 16-bit linear PCM (rates up to limit of hardware)</td>
<td>WAVE (.wav)</td>
</tr>
<tr>
<td rowspan="5"><b>Image</b></td>
</tr>
<tr>
<td>JPEG</td>
<td>base+progressive</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>GIF</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>PNG</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>BMP</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="4"><b>Video</b></td>
</tr>
<tr>
<td>H.263</td>
<td>&nbsp;</td>
<td>3GPP (.3gp) files</td>
</tr>
<tr>
<td>H.264</td>
<td>&nbsp;</td>
<td>3GPP (.3gp) and MPEG-4 (.mp4) files</td>
</tr>
<tr>
<td>MPEG4 Simple Profile</td>
<td>&nbsp;</td>
<td>3GPP (.3gp) file</td>
</tr>
</tbody>
</table>

<a name="section-5.1.2"></a><h3>5.1.2. Media Encoders</h3>
<p>Device implementations SHOULD include encoders for as many of the media
formats listed in Section 5.1.1. as possible. However, some encoders do not
make sense for devices that lack certain optional hardware; for instance,
an encoder for the H.263 video does not make sense, if the device lacks any
cameras. Device implementations MUST therefore implement media encoders
according to the conditions described in the table below.</p>
<p>See Section 7 for details on the conditions under which hardware may be
omitted by device implementations.</p>
<table><tbody>
<tr>
<td rowspan="5"><b>Audio</b></td>
</tr>
<tr>
<td><b>Name</b></td>
<td><b>Details</b></td>
<td><b>File/Container Format</b></td>
<td><b>Conditions</b></td>
</tr>
<tr>
<td>AMR-NB</td>
<td>4.75 to 12.2 kbps sampled @ 8kHz</td>
<td>3GPP (.3gp)</td>
<td rowspan="3">Device implementations that include microphone hardware and define
<code>android.hardware.microphone</code> MUST include encoders for these audio
formats.</td>
</tr>
<tr>
<td>AMR-WB</td>
<td>9 rates from 6.60 kbit/s to 23.85 kbit/s sampled @ 16kHz</td>
<td>3GPP (.3gp)</td>
</tr>
<tr>
<td>AAC LC/LTP</td>
<td rowspan="1">Mono/Stereo content in any combination of standard bit rates up to 160 kbps and sampling rates between 8 to 48kHz</td>
<td rowspan="1">3GPP (.3gp) and MPEG-4 (.mp4, .m4a).</td>
</tr>
<tr>
<td rowspan="2"><b>Image</b></td>
<td>JPEG</td>
<td>base+progressive</td>
<td>&nbsp;</td>
<td rowspan="2">All device implementations MUST include encoders for these
image formats, as Android 2.3 includes APIs that applications can use to
programmatically generate files of these types.</td>
</tr>
<tr>
<td>PNG</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><b>Video</b></td>
<td>H.263</td>
<td>&nbsp;</td>
<td>3GPP (.3gp) files</td>
<td>Device implementations that include camera hardware and define
either <code>android.hardware.camera</code> or
<code>android.hardware.camera.front</code> MUST include encoders for these
video formats.</td>
</tr>
</tbody>
</table>
<p>In addition to the encoders listed above, device implementations SHOULD include an H.264
encoder. Note that the Compatibility Definition for a future version is planned
to change this requirement to "MUST". That is, H.264 encoding is optional in Android
2.3 but <b>will be required</b> by a future version. Existing and new devices 
that run Android 2.3 are <b>very strongly encouraged to meet
this requirement in Android 2.3</b>, or they will not be able to attain
Android compatibility when upgraded to the future version.</p>

<a name="section-5.2"></a><h3>5.2. Audio Recording</h3>
<p>When an application has used the <code>android.media.AudioRecord</code> API to
start recording an audio stream, device implementations SHOULD sample and
record audio with each of these behaviors:</p>
<ul>
<li>Noise reduction processing, if present, SHOULD be disabled.</li>
<li>Automatic gain control, if present, SHOULD be disabled.</li>
<li>The device SHOULD exhibit approximately flat amplitude versus frequency
    characteristics; specifically, &plusmn;3 dB, from 100 Hz to 4000 Hz</li>
<li>Audio input sensitivity SHOULD be set such that a 90 dB sound power level
    (SPL) source at 1000 Hz yields RMS of 5000 for 16-bit samples.</li>
<li>PCM amplitude levels SHOULD linearly track input SPL changes over at least
    a 30 dB range from -18 dB to +12 dB re 90 dB SPL at the microphone.</li>
<li>Total harmonic distortion SHOULD be less than 1% from 100 Hz to 4000 Hz at
    90 dB SPL input level.</li>
</ul>
<p><b>Note:</b> while the requirements outlined above are stated as "SHOULD"
for Android 2.3, the Compatibility Definition for a future version is planned
to change these to "MUST". That is, these requirements are optional in Android
2.3 but <b>will be required</b> by a future version. Existing and new devices 
that run Android 2.3 are <b>very strongly encouraged to meet
these requirements in Android 2.3</b>, or they will not be able to attain
Android compatibility when upgraded to the future version.</p>

<a name="section-5.3"></a><h3>5.3. Audio Latency</h3>
<p>Audio latency is broadly defined as the interval between when an
application requests an audio playback or record operation, and when the
device implementation actually begins the operation. Many classes of
applications rely on short latencies, to achieve real-time effects such sound
effects or VOIP communication. Device implementations that include microphone
hardware and declare <code>android.hardware.microphone</code> SHOULD meet all
audio latency requirements outlined in this section.  See Section 7 for
details on the conditions under which microphone hardware may be omitted by
device implementations.</p>
<p>For the purposes of this section:</p>
<ul>
<li>"cold output latency" is defined to be the interval between when an
    application requests audio playback and when sound begins playing, when
    the audio system has been idle and powered down prior to the request</li>
<li>"warm output latency" is defined to be the interval between when an
    application requests audio playback and when sound begins playing, when
    the audio system has been recently used but is currently idle (that is,
    silent)</li>
<li>"continuous output latency" is defined to be the interval between when an
    application issues a sample to be played and when the speaker physically
    plays the corresponding sound, while the device is currently playing back
    audio</li>
<li>"cold input latency" is defined to be the interval between when an
    application requests audio recording and when the first sample is
    delivered to the application via its callback, when the audio system and
    microphone has been idle and powered down prior to the request</li>
<li>"continuous input latency" is defined to be when an ambient sound occurs
    and when the sample corresponding to that sound is delivered to a
    recording application via its callback, while the device is in recording
    mode</li>
</ul>
<p>Using the above definitions, device implementations SHOULD exhibit each of
these properties:</p>
<ul>
<li>cold output latency of 100 milliseconds or less</li>
<li>warm output latency of 10 milliseconds or less</li>
<li>continuous output latency of 45 milliseconds or less</li>
<li>cold input latency of 100 milliseconds or less</li>
<li>continuous input latency of 50 milliseconds or less</li>
</ul>
<p><b>Note:</b> while the requirements outlined above are stated as "SHOULD"
for Android 2.3, the Compatibility Definition for a future version is planned
to change these to "MUST". That is, these requirements are optional in Android
2.3 but <b>will be required</b> by a future version. Existing and new devices 
that run Android 2.3 are <b>very strongly encouraged to meet
these requirements in Android 2.3</b>, or they will not be able to attain
Android compatibility when upgraded to the future version.</p>
<p>If a device implementation meets the requirements of this section, it MAY
report support for low-latency audio, by reporting the feature
"android.hardware.audio.low-latency" via the
<code>android.content.pm.PackageManager</code> class. [<a
href="#resources27">Resources, 27</a>] Conversely, if the device
implementation does not meet these requirements it MUST NOT report support for
low-latency audio.</p>

<a name="section-6"></a><h2>6. Developer Tool Compatibility</h2>
<p>Device implementations MUST support the Android Developer Tools provided in
the Android SDK. Specifically, Android-compatible devices MUST be compatible
with:</p>
<ul>
<li><b>Android Debug Bridge (known as adb)</b> [<a href="#resources23">Resources, 23</a>]<br/>
Device implementations MUST support all <code>adb</code> functions as
documented in the Android SDK. The device-side <code>adb</code> daemon SHOULD
be inactive by default, but there MUST be a user-accessible mechanism to turn
on the Android Debug Bridge.</li>
<li><b>Dalvik Debug Monitor Service (known as ddms)</b> [<a href="#resources23">Resources, 23</a>]<br/>
Device implementations MUST support all <code>ddms</code> features as documented in the
Android SDK. As <code>ddms</code> uses <code>adb</code>, support for
<code>ddms</code> SHOULD be inactive by default,
but MUST be supported whenever the user has activated the Android Debug
Bridge, as above.</li>
<li><b>Monkey</b> [<a href="#resources26">Resources, 26</a>]<br/>
Device implementations MUST include the Monkey framework, and make it
available for applications to use.</li>
</ul>
<p>Most Linux-based systems and Apple Macintosh systems recognize Android
devices using the standard Android SDK tools, without additional support;
however Microsoft Windows systems typically require a driver for new Android
devices. (For instance, new vendor IDs and sometimes new device IDs require
custom USB drivers for Windows systems.) If a device implementation is
unrecognized by the <code>adb</code> tool as provided in the standard Android
SDK, device implementers MUST provide Windows drivers allowing developers to
connect to the device using the <code>adb</code> protocol. These drivers MUST
be provided for Windows XP, Windows Vista, and Windows 7, in both 32-bit and
64-bit versions.</p>

<a name="section-7"></a><h2>7. Hardware Compatibility</h2>
<p>Android is intended to enable device implementers to create innovative form 
factors and configurations. At the same time Android developers write
innovative applications that rely on the various hardware and features
available through the Android APIs. The requirements in this section strike a
balance between innovations available to device implementers, and the needs of
developers to ensure their apps are only available to devices where they will
run properly.</p>
<p>If a device includes a particular hardware component that has a 
corresponding API for third-party developers, the device implementation MUST
implement that API as described in the Android SDK documentation. If an API in
the SDK interacts with a hardware component that is stated to be optional and the device
implementation does not possess that component:</p>
<ul>
<li>complete class definitions (as documented by the SDK) for the component's APIs MUST still be present</li>
<li>the API's behaviors MUST be implemented as no-ops in some reasonable fashion</li>
<li>API methods MUST return null values where permitted by the SDK documentation</li>
<li>API methods MUST return no-op implementations of classes where null values are not permitted by the SDK documentation</li>
<li>API methods MUST NOT throw exceptions not documented by the SDK documentation</li>
</ul>
<p>A typical example of a scenario where these requirements apply is the
telephony API: even on non-phone devices, these APIs must be implemented as
reasonable no-ops.</p>
<p>Device implementations MUST accurately report accurate hardware configuration
information via the <code>getSystemAvailableFeatures()</code> and
<code>hasSystemFeature(String)</code> methods on the
<code>android.content.pm.PackageManager</code> class. [<a
href="#resources27">Resources, 27</a>]</p>

<a name="section-7.1"></a><h3>7.1. Display and Graphics</h3>
<p>Android 2.3 includes facilities that automatically adjust application
assets and UI layouts appropriately for the device, to ensure that third-party
applications run well on a variety of hardware configurations [<a
href="#resources28">Resources, 28</a>]. Devices MUST properly implement these
APIs and behaviors, as detailed in this section.</p>
<a name="section-7.1.1"></a><h4>7.1.1. Screen Configurations</h4>
<p>Device implementations MAY use screens of any pixel dimensions, provided
that they meet the following requirements:</p>
<ul>
<li>screens MUST be at least 2.5 inches in physical diagonal size</li>
<li>density MUST be at least 100 dpi</li>
<li>the aspect ratio MUST be between 1.333 (4:3) and 1.779 (16:9)</li>
<li>the display technology used consists of square pixels</li>
</ul>
<p>Device implementations with a screen meeting the requirements above are
considered compatible, and no additional action is necessary.  The Android
framework implementation automatically computes display characteristics such
as screen size bucket and density bucket. In the majority of cases, the
framework decisions are the correct ones. If the default framework
computations are used, no additional action is necessary.  Device implementers
wishing to change the defaults, or use a screen that does not meet the
requirements above MUST contact the Android Compatibility Team for guidance,
as provided for in Section 12.</p>
<p>The units used by the requirements above are defined as follows:</p>
<ul>
<li>"Physical diagonal size" is the distance in inches between two opposing
corners of the illuminated portion of the display.</li>
<li>"dpi" (meaning "dots per inch") is the number of pixels encompassed by a
linear horizontal or vertical span of 1". Where dpi values are listed, both
horizontal and vertical dpi must fall within the range.</li>
<li>"Aspect ratio" is the ratio of the longer dimension of the screen to the
shorter dimension. For example, a display of 480x854 pixels would be 854 / 480
= 1.779, or roughly "16:9".</li>
</ul>
<p>Device implementations MUST use only displays with a single static
configuration. That is, device implementations MUST NOT enable multiple
screen configurations. For instance, since a typical television supports
multiple resolutions such as 1080p, 720p, and so on, this configuration is not
compatible with Android 2.3. (However, support for such configurations is
under investigation and planned for a future version of Android.)</p>
<a name="section-7.1.2"></a><h4>7.1.2. Display Metrics</h4>
<p>Device implementations MUST report correct values for all display metrics
defined in <code>android.util.DisplayMetrics</code> [<a
href="#resources29">Resources, 29</a>].</p>
<a name="section-7.1.3"></a><h4>7.1.3. Declared Screen Support</h4>
<p>Applications optionally indicate which screen sizes they support via the
<code>&lt;supports-screens&gt;</code> attribute in the AndroidManifest.xml
file. Device implementations MUST correctly honor applications' stated support
for small, medium, and large screens, as described in the Android
SDK documentation.</p>
<a name="section-7.1.4"></a><h4>7.1.4. Screen Orientation</h4>
<p>Compatible devices MUST support dynamic orientation by applications to
either portrait or landscape screen orientation. That is, the device must
respect the application's request for a specific screen orientation. Device
implementations MAY select either portrait or landscape orientation as the
default. Devices that cannot be physically rotated MAY meet this requirement
by "letterboxing" applications that request portrait mode, using only a
portion of the available display.</p>
<p>Devices MUST report the correct value for the device's current orientation,
whenever queried via the android.content.res.Configuration.orientation,
android.view.Display.getOrientation(), or other APIs.</p>
<a name="section-7.1.5"></a><h4>7.1.5. 3D Graphics Acceleration</h4>
<p>Device implementations MUST support OpenGL ES 1.0, as required by the
Android 2.3 APIs. For devices that lack 3D acceleration hardware, a software
implementation of OpenGL ES 1.0 is provided by the upstream Android
Open-Source Project. Device implementations SHOULD support OpenGL ES 2.0.</p>
<p>Implementations MAY omit Open GL ES 2.0 support; however if support is
ommitted, device implementations MUST NOT report as supporting OpenGL ES 2.0.
Specifically, if a device implementations lacks OpenGL ES 2.0 support:</p>
<ul>
<li>the managed APIs (such as via the <code>GLES10.getString()</code> method)
MUST NOT report support for OpenGL ES 2.0</li>
<li>the native C/C++ OpenGL APIs (that is, those available to apps via
libGLES_v1CM.so, libGLES_v2.so, or libEGL.so) MUST NOT report support for
OpenGL ES 2.0.</li>
</ul>
<p>Conversely, if a device implementation <i>does</i> support OpenGL ES 2.0,
it MUST accurately report that support via the routes just listed.</p>
<p>Note that Android 2.3 includes support for applications to optionally
specify that they require specific OpenGL texture compression formats. These
formats are typically vendor-specific. Device implementations are not required
by Android 2.3 to implement any specific texture compression format. However,
they SHOULD accurately report any texture compression formats that they do
support, via the <code>getString()</code> method in the OpenGL API.</p>

<a name="section-7.2"></a><h3>7.2. Input Devices</h3>
<p>Android 2.3 supports a number of modalities for user input. Device
implementations MUST support user input devices as provided for in this
section.</p>
<a name="section-7.2.1"></a><h4>7.2.1. Keyboard</h4>
<p>Device implementations:</p>
<ul>
<li>MUST include support for the Input Management Framework (which allows third party developers to create Input Management Engines -- i.e. soft keyboard) as detailed at developer.android.com</li>
<li>MUST provide at least one soft keyboard implementation (regardless of whether a hard keyboard is present)</li>
<li>MAY include additional soft keyboard implementations</li>
<li>MAY include a hardware keyboard</li>
<li>MUST NOT include a hardware keyboard that does not match one of the
formats specified in <code>android.content.res.Configuration.keyboard</code>
[<a href="#resources30">Resources, 30</a>] (that is, QWERTY, or 12-key)</li>
</ul>
<a name="section-7.2.2"></a><h4>7.2.2. Non-touch Navigation</h4>
<p>Device implementations:</p>
<ul>
<li>MAY omit a non-touch navigation option (that is, may omit a trackball, d-pad, or wheel)</li>
<li>MUST report the correct value for
<code>android.content.res.Configuration.navigation</code> [<a href="#resources30">Resources, 30</a>]</li>
<li>MUST provide a reasonable alternative user interface mechanism for the
selection and editing of text, compatible with Input Management Engines. The
upstream Android Open-Source code includes a selection mechanism suitable for
use with devices that lack non-touch navigation inputs.</li>
</ul>
<a name="section-7.2.3"></a><h4>7.2.3. Navigation keys</h4>
<p>The Home, Menu and Back functions are essential to the Android navigation
paradigm. Device implementations MUST make these functions available to the
user at all times, regardless of application state. These functions SHOULD be
implemented via dedicated buttons. They MAY be implemented using software,
gestures, touch panel, etc., but if so they MUST be always accessible and not
obscure or interfere with the available application display area.</p>
<p>Device implementers SHOULD also provide a dedicated search key. Device
implementers MAY also provide send and end keys for phone calls.</p>
<a name="section-7.2.4"></a><h4>7.2.4. Touchscreen input</h4>
<p>Device implementations:</p>
<ul>
<li>MUST have a touchscreen</li>
<li>MAY have either capacitive or resistive touchscreen</li>
<li>MUST report the value of <code>android.content.res.Configuration</code>
[<a href="#resources30">Resources, 30</a>]
reflecting corresponding to the type of the specific touchscreen on the
device</li>
<li>SHOULD support fully independently tracked pointers, if the touchscreen supports multiple pointers</li>
</ul>

<a name="section-7.3"></a><h3>7.3. Sensors</h3>
<p>Android 2.3 includes APIs for accessing a variety of sensor types. Devices
implementations generally MAY omit these sensors, as provided for in the
following subsections. If a device includes a particular sensor type that has a 
corresponding API for third-party developers, the device implementation MUST
implement that API as described in the Android SDK documentation. For example,
device implementations:</p>
<ul>
<li>MUST accurately report the presence or absence of sensors per the
<code>android.content.pm.PackageManager</code> class. [<a
href="#resources27">Resources, 27</a>]</li>
<li>MUST return an accurate list of supported sensors via the
<code>SensorManager.getSensorList()</code> and similar methods</li>
<li>MUST behave reasonably for all other sensor APIs (for example, by
returning true or false as appropriate when applications attempt to register
listeners, not calling sensor listeners when the corresponding sensors are not
present; etc.)</li>
</ul>
<p>The list above is not comprehensive; the documented behavior of the Android
SDK is to be considered authoritative.</p>
<p>Some sensor types are synthetic, meaning they can be derived from data
provided by one or more other sensors. (Examples include the orientation
sensor, and the linear acceleration sensor.) Device implementations SHOULD
implement these sensor types, when they include the prerequisite physical
sensors.</p>
<p>The Android 2.3 APIs introduce a notion of a "streaming" sensor, which is
one that returns data continuously, rather than only when the data changes.
Device implementations MUST continuously provide periodic data samples for any
API indicated by the Android 2.3 SDK documentation to be a streaming
sensor.</p>
<a name="section-7.3.1"></a><h4>7.3.1. Accelerometer</h4>
<p>Device implementations SHOULD include a 3-axis accelerometer. If a device
implementation does include a 3-axis accelerometer, it:</p>
<ul>
<li>MUST be able to deliver events at 50 Hz or greater</li>
<li>MUST comply with the Android sensor coordinate system as detailed
in the Android APIs (see [<a href="#resources31">Resources, 31</a>])</li>
<li>MUST be capable of measuring from freefall up to twice gravity (2g) or
more on any three-dimensional vector</li>
<li>MUST have 8-bits of accuracy or more</li>
<li>MUST have a standard deviation no greater than 0.05 m/s^2</li>
</ul>
<a name="section-7.3.2"></a><h4>7.3.2. Magnetometer</h4>
<p>Device implementations SHOULD include a 3-axis magnetometer (i.e. compass.)
If a device does include a 3-axis magnetometer, it:</p>
<ul>
<li>MUST be able to deliver events at 10 Hz or greater</li>
<li>MUST comply with the Android sensor coordinate system as detailed
in the Android APIs (see [<a href="#resources31">Resources, 31</a>]).</li>
<li>MUST be capable of sampling a range of field strengths adequate to cover the geomagnetic field</li>
<li>MUST have 8-bits of accuracy or more</li>
<li>MUST have a standard deviation no greater than 0.5 &micro;T</li>
</ul>
<a name="section-7.3.3"></a><h4>7.3.3. GPS</h4>
<p>Device implementations SHOULD include a GPS receiver. If a device
implementation does include a GPS receiver, it SHOULD include
some form of "assisted GPS" technique to minimize GPS lock-on time.</p>
<a name="section-7.3.4"></a><h4>7.3.4. Gyroscope</h4>
<p>Device implementations SHOULD include a gyroscope (i.e. angular change
sensor.) Devices SHOULD NOT include a gyroscope sensor unless a 3-axis
accelerometer is also included. If a device implementation includes a
gyroscope, it:</p>
<ul>
<li>MUST be capable of measuring orientation changes up to 5.5*Pi
radians/second (that is, approximately 1,000 degrees per second)</li>
<li>MUST be able to deliver events at 100 Hz or greater</li>
<li>MUST have 8-bits of accuracy or more</li>
</ul>
<a name="section-7.3.5"></a><h4>7.3.5. Barometer</h4>
<p>Device implementations MAY include a barometer (i.e. ambient air pressure
sensor.) If a device implementation includes a barometer, it:</p>
<ul>
<li>MUST be able to deliver events at 5 Hz or greater</li>
<li>MUST have adequate precision to enable estimating altitude</li>
</ul>
<a name="section-7.3.6"></a><h4>7.3.7. Thermometer</h4>
<p>Device implementations MAY but SHOULD NOT include a thermometer (i.e.
temperature sensor.) If a device implementation does include a thermometer, it
MUST measure the temperature of the device CPU. It MUST NOT measure any other
temperature. (Note that this sensor type is deprecated in the Android 2.3
APIs.)</p>
<a name="section-7.3.7"></a><h4>7.3.7. Photometer</h4>
<p>Device implementations MAY include a photometer (i.e. ambient light
sensor.)</p>
<a name="section-7.3.8"></a><h4>7.3.8. Proximity Sensor</h4>
<p>Device implementations MAY include a proximity sensor.  If a device
implementation does include a proximity sensor, it MUST measure the proximity
of an object in the same direction as the screen. That is, the proximity
sensor MUST be oriented to detect objects close to the screen, as the
primary intent of this sensor type is to detect a phone in use by the
user. If a device implementation includes a proximity sensor with any other
orientation, it MUST NOT be accessible through this API. If a device
implementation has a proximity sensor, it MUST be have 1-bit of accuracy or
more.</p>

<a name="section-7.4"></a><h3>7.4. Data Connectivity</h3>
<p>Network connectivity and access to the Internet are vital features of
Android. Meanwhile, device-to-device interaction adds significant value to
Android devices and applications. Device implementations MUST meet the
data connectivity requirements in this section.</p>
<a name="section-7.4.1"></a><h4>7.4.1. Telephony</h4>
<p>"Telephony" as used by the Android 2.3 APIs and this document refers
specifically to hardware related to placing voice calls and sending SMS
messages via a GSM or CDMA network. While these voice calls may or may not be
packet-switched, they are for the purposes of Android 2.3 considered
independent of any data connectivity that may be implemented using the same
network. In other words, the Android "telephony" functionality and APIs refer
specifically to voice calls and SMS; for instance, device implementations that
cannot place calls or send/receive SMS messages MUST NOT report the
"android.hardware.telephony" feature or any sub-features, regardless of
whether they use a cellular network for data connectivity.</p>
<p>Android 2.3 MAY be used on devices that do not include telephony hardware.
That is, Android 2.3 is compatible with devices that are not phones.
However, if a device implementation does include GSM or CDMA telephony, it
MUST implement full support for the API for that technology. Device
implementations that do not include telephony hardware MUST implement the full
APIs as no-ops.</p>
<a name="section-7.4.2"></a><h4>7.4.2. IEEE 802.11 (WiFi)</h4>
<p>Android 2.3 device implementations SHOULD include support for one or more
forms of 802.11 (b/g/a/n, etc.) If a device implementation does include
support for 802.11, it MUST implement the corresponding Android API.</p>
<a name="section-7.4.3"></a><h4>7.4.3. Bluetooth</h4>
<p>Device implementations SHOULD include a Bluetooth transceiver. Device
implementations that do include a Bluetooth transceiver MUST enable the
RFCOMM-based Bluetooth API as described in the SDK documentation [<a
href="#resources32">Resources, 32</a>]. Device implementations SHOULD
implement relevant Bluetooth profiles, such as A2DP, AVRCP, OBEX, etc. as
appropriate for the device.</p>
<p>The Compatibility Test Suite includes cases that cover basic operation of
the Android RFCOMM Bluetooth API. However, since Bluetooth is a communications
protocol between devices, it cannot be fully tested by unit tests running on a
single device. Consequently, device implementations MUST also pass the
human-driven Bluetooth test procedure described in Appendix A.</p>
<a name="section-7.4.4"></a><h4>7.4.4. Near-Field Communications</h4>
<p>Device implementations SHOULD include a transceiver and related hardware
for Near-Field Communications (NFC). If a device implementation does include
NFC hardware, then it:</p>
<ul>
<li>MUST report the android.hardware.nfc feature from the
<code>android.content.pm.PackageManager.hasSystemFeature()</code> method. [<a href="#resources27">Resources, 27</a>]</li>
<li>MUST be capable of reading and writing NDEF messages via the following NFC
standards:<ul>
<li>MUST be capable of acting as an NFC Forum reader/writer
(as defined by the NFC Forum technical specification
NFCForum-TS-DigitalProtocol-1.0) via the following NFC standards:<ul>
  <li>NfcA (ISO14443-3A)</li>
  <li>NfcB (ISO14443-3B) </li>
  <li>NfcF (JIS 6319-4)</li>
  <li>NfcV (ISO 15693)</li>
  <li>IsoDep (ISO 14443-4)</li>
  <li>NFC Forum Tag Types 1, 2, 3, 4 (defined by the NFC Forum)</li>
</ul></li>
<li>MUST be capable of transmitting and receiving data via the following
peer-to-peer standards and protocols:<ul>
  <li>ISO 18092</li>
  <li>LLCP 1.0 (defined by the NFC Forum)</li>
  <li>SDP 1.0 (defined by the NFC Forum)</li>
  <li>NDEF Push Protocol [<a href="#resources33">Resources, 33</a>]</li>
</ul></li>
<li>MUST scan for all supported technologies while in NFC discovery mode.</li>
<li>SHOULD be in NFC discovery mode while the device is awake with the screen active.</li>
</ul>
<p>(Note that publicly available links are not available for the JIS, ISO, and
NFC Forum specifications cited above.)</p>
<p>Additionally, device implementations SHOULD support the following
widely-deployed MIFARE technologies.</p>
<ul>
  <li>MIFARE Classic (NXP MF1S503x [<a href="#resources34">Resources, 34</a>], MF1S703x [<a href="#resources35">Resources, 35</a>])</li>
  <li>MIFARE Ultralight (NXP MF0ICU1 [<a href="#resources36">Resources, 36</a>], MF0ICU2 [<a href="#resources37">Resources, 37</a>])</li>
  <li>NDEF on MIFARE Classic (NXP AN130511 [<a href="#resources38">Resources, 38</a>], AN130411 [<a href="#resources39">Resources, 39</a>])</li>
</ul>
<p>Note that Android 2.3.3 includes APIs for these MIFARE types. If a
device implementation supports MIFARE, it:</p>
<ul>
  <li>MUST implement the corresponding Android APIs as documented by the
  Android SDK</li>
  <li>MUST report the feature com.nxp.mifare from the
  <code>android.content.pm.PackageManager.hasSystemFeature()</code> method.
  [<a href="#resources27">Resources, 27</a>] Note that this is not a standard
  Android feature, and as such does not appear as a constant on the
  <code>PackageManager</code> class.</li>
  <li>MUST NOT implement the corresponding Android APIs nor report the
  com.nxp.mifare feature unless it also implements general NFC support as
  described in this section</li>
</ul>
<p>If a device implementation does not include NFC hardware, it MUST NOT
declare the android.hardware.nfc feature from the 
<code>android.content.pm.PackageManager.hasSystemFeature()</code> method [<a
href="#resources27">Resources, 27</a>], and MUST implement the Android 2.3 NFC
API as a no-op.</p>
<p>As the classes <code>android.nfc.NdefMessage</code> and
<code>android.nfc.NdefRecord</code> represent a protocol-independent data
representation format, device implementations MUST implement these APIs even
if they do not include support for NFC or declare the android.hardware.nfc
feature.</p>
<a name="section-7.4.5"></a><h4>7.4.5. Minimum Network Capability</h4>
<p>Device implementations MUST include support for one or more forms of data
networking. Specifically, device implementations MUST include support for at
least one data standard capable of 200Kbit/sec or greater. Examples of
technologies that satisfy this requirement include EDGE, HSPA, EV-DO, 802.11g,
Ethernet, etc.</p>
<p>Device implementations where a physical networking standard (such as
Ethernet) is the primary data connection SHOULD also include support for at
least one common wireless data standard, such as 802.11 (WiFi).</p>
<p>Devices MAY implement more than one form of data connectivity.</p>


<a name="section-7.5"></a><h3>7.5. Cameras</h3>
<p>Device implementations SHOULD include a rear-facing camera, and MAY include
a front-facing camera. A rear-facing camera is a camera located on the side of
the device opposite the display; that is, it images scenes on the far side of
the device, like a traditional camera. A front-facing camera is a camera
located on the same side of the device as the display; that is, a camera
typically used to image the user, such as for video conferencing and similar
applications.</p>
<a name="section-7.5.1"></a><h4>7.5.1. Rear-Facing Camera</h4>
<p>Device implementations SHOULD include a rear-facing camera. If a device
implementation includes a rear-facing camera, it:</p>
<ul>
<li>MUST have a resolution of at least 2 megapixels</li>
<li>SHOULD have either hardware auto-focus, or software auto-focus implemented
in the camera driver (transparent to application software)</li>
<li>MAY have fixed-focus or EDOF (extended depth of field) hardware</li>
<li>MAY include a flash. If the Camera includes a flash, the flash lamp MUST
NOT be lit while an android.hardware.Camera.PreviewCallback instance has been
registered on a Camera preview surface, unless the application has explicitly
enabled the flash by enabling the <code>FLASH_MODE_AUTO</code> or
<code>FLASH_MODE_ON</code> attributes of a <code>Camera.Parameters</code>
object. Note that this constraint does not apply to the device's built-in
system camera application, but only to third-party applications using
<code>Camera.PreviewCallback</code>.</li>
</ul>
<a name="section-7.5.2"></a><h4>7.5.2. Front-Facing Camera</h4>
<p>Device implementations MAY include a front-facing camera. If a device
implementation includes a front-facing camera, it:</p>
<ul>
<li>MUST have a resolution of at least VGA (that is, 640x480 pixels)</li>
<li>MUST NOT use a front-facing camera as the default for the Camera API.
That is, the camera API in Android 2.3 has specific support for front-facing
cameras, and device implementations MUST NOT configure the API to to treat a
front-facing camera as the default rear-facing camera, even if it is the only
camera on the device.</li>
<li>MAY include features (such as auto-focus, flash, etc.)
available to rear-facing cameras as described in Section 7.5.1.</li>
<li>MUST horizontally reflect (i.e. mirror) the stream displayed by an app in a
CameraPreview, as follows:</li>
<ul>
<li>If the device implementation is capable of being rotated by user (such as
automatically via an accelerometer or manually via user input), the camera
preview MUST be mirrored horizontally relative to the device's current
orientation.</li>
<li>If the current application has explicitly requested that the Camera
display be rotated via a call to the
<code>android.hardware.Camera.setDisplayOrientation()</code> [<a
href="#resources40">Resources, 40</a>] method, the camera preview MUST be
mirrored horizontally relative to the orientation specified by the
application.</li>
<li>Otherwise, the preview MUST be mirrored along the device's default horizontal axis.</li>
</ul>
<li>MUST mirror the image data returned to any "postview" camera callback
handlers, in the same manner as the camera preview image stream. (If the device
implementation does not support postview callbacks, this requirement obviously
does not apply.)</li>
<li>MUST NOT mirror the final captured still image or video streams returned
to application callbacks or committed to media storage</li>
</ul>
<a name="section-7.5.3"></a><h4>7.5.3. Camera API Behavior</h4>
<p>Device implementations MUST implement the following behaviors for the
camera-related APIs, for both front- and rear-facing cameras:</p>
<ol>
<li>If an application has never called
android.hardware.Camera.Parameters.setPreviewFormat(int), then the device MUST
use android.hardware.PixelFormat.YCbCr_420_SP for preview data provided to
application callbacks.</li>
<li>If an application registers an android.hardware.Camera.PreviewCallback
instance and the system calls the onPreviewFrame() method when the preview
format is YCbCr_420_SP, the data in the byte[] passed into onPreviewFrame()
must further be in the NV21 encoding format. That is, NV21 MUST be the default.</li>
<li>Device implementations SHOULD support the YV12 format (as denoted by the
<code>android.graphics.ImageFormat.YV12</code> constant) for camera previews
for both front- and rear-facing cameras. Note that the Compatibility
Definition for a future version is planned to change this requirement to
"MUST". That is, YV12 support is optional in Android 2.3 but <b>will be
required</b> by a future version. Existing and new devices that run Android
2.3 are <b>very strongly encouraged to meet this requirement in Android
2.3</b>, or they will not be able to attain Android compatibility when
upgraded to the future version.</li>
</ol>
<p>Device implementations MUST implement the full Camera API included in the
Android 2.3 SDK documentation [<a href="#resources41">Resources, 41</a>]),
regardless of whether the device includes hardware autofocus or other
capabilities. For instance, cameras that lack autofocus MUST still call any
registered <code>android.hardware.Camera.AutoFocusCallback</code> instances (even though
this has no relevance to a non-autofocus camera.) Note that this does apply
to front-facing cameras; for instance, even though most front-facing cameras
do not support autofocus, the API callbacks must still be "faked" as
described.</p>
<p>Device implementations MUST recognize and honor each parameter name defined
as a constant on the <code>android.hardware.Camera.Parameters</code> class, if the
underlying hardware supports the feature. If the device hardware does not
support a feature, the API must behave as documented. Conversely, Device
implementations MUST NOT honor or recognize string constants passed
to the <code>android.hardware.Camera.setParameters()</code> method other than
those documented as constants on the
<code>android.hardware.Camera.Parameters</code>.  That is,
device implementations MUST support all standard Camera parameters if the
hardware allows, and MUST NOT support custom Camera parameter types.</p>
<a name="section-7.5.4"></a><h4>7.5.4. Camera Orientation</h4>
<p>Both front- and rear-facing cameras, if present, MUST be oriented so that
the long dimension of the camera aligns with the screen's long dimention. That
is, when the device is held in the landscape orientation, a cameras MUST
capture images in the landscape orientation. This applies regardless of the
device's natural orientation; that is, it applies to landscape-primary devices
as well as portrait-primary devices.</p>


<a name="section-7.6"></a><h3>7.6. Memory and Storage</h3>
<p>The fundamental function of Android 2.3 is to run applications. Device
implementations MUST the requirements of this section, to ensure adequate
storage and memory for applications to run properly.</p>
<a name="section-7.6.1"></a><h4>7.6.1. Minimum Memory and Storage</h4>
<p>Device implementations MUST have at least 128MB of memory available to the
kernel and userspace. The 128MB MUST be in addition to any memory dedicated to
hardware components such as radio, memory, and so on that is not under the
kernel's control.</p>
<p>Device implementations MUST have at least 150MB of non-volatile storage
available for user data. That is, the <code>/data</code> partition MUST be at
least 150MB.</p>
<p>Beyond the requirements above, device implementations SHOULD have at least
1GB of non-volatile storage available for user data. Note that this higher
requirement is planned to become a hard minimum in a future version of
Android. Device implementations are strongly encouraged to meet these
requirements now, or else they may not be eligible for compatibility for a
future version of Android.</p>
<p>The Android APIs include a Download Manager that applications may use to
download data files. The Download Manager implementation MUST be capable of
downloading individual files 55MB in size, or larger. The Download Manager
implementation SHOULD be capable of downloading files 100MB in size, or
larger.</p>
<a name="section-7.6.2"></a><h4>7.6.2. Application Shared Storage</h4>
<p>Device implementations MUST offer shared storage for applications. The
shared storage provided MUST be at least 1GB in size.</p>
<p>Device implementations MUST be configured with shared storage mounted by
default, "out of the box". If the shared storage is not mounted on the Linux
path <code>/sdcard</code>, then the device MUST include a Linux symbolic link
from <code>/sdcard</code> to the actual mount point.</p>
<p>Device implementations MUST enforce as documented the
<code>android.permission.WRITE_EXTERNAL_STORAGE</code> permission on this
shared storage. Shared storage MUST otherwise be writable by any application
that obtains that permission.</p>
<p>Device implementations MAY have hardware for user-accessible removable
storage, such as a Secure Digital card. Alternatively, device implementations
MAY allocate internal (non-removable) storage as shared storage for apps.</p>
<p>Regardless of the form of shared storage used, device implementations MUST
provide some mechanism to access the contents of shared storage from a host
computer, such as USB mass storage or Media Transfer Protocol.</p>
<p>It is illustrative to consider two common examples. If a device
implementation includes an SD card slot to satisfy the shared storage
requirement, a FAT-formatted SD card 1GB in size or larger MUST be included
with the device as sold to users, and MUST be mounted by default.
Alternatively, if a device implementation uses internal fixed storage to
satisfy this requirement, that storage MUST be 1GB in size or larger
and mounted on <code>/sdcard</code> (or <code>/sdcard</code>
MUST be a symbolic link to the physical location if it is mounted elsewhere.)</p>
<p>Device implementations that include multiple shared storage paths (such as
both an SD card slot and shared internal storage) SHOULD modify the core
applications such as the media scanner and ContentProvider to transparently
support files placed in both locations.</p>

<a name="section-7.7"></a><h3>7.7. USB</h3>
<p>Device implementations:</p>
<ul>
<li>MUST implement a USB client, connectable to a USB host with a standard
USB-A port</li>
<li>MUST implement the Android Debug Bridge over USB (as described in Section
7)</li>
<li>MUST implement the USB mass storage specification, to allow a host
connected to the device to access the contents of the /sdcard volume </li>
<li>SHOULD use the micro USB form factor on the device side</li>
<li>MAY include a non-standard port on the device side, but if so MUST ship
with a cable capable of connecting the custom pinout to standard USB-A
port</li>
</ul>


<a name="section-8"></a><h2>8. Performance Compatibility</h2>
<p>Compatible implementations must ensure not only that applications simply
run correctly on the device, but that they do so with reasonable performance
and overall good user experience.  Device implementations MUST meet the key
performance metrics of an Android 2.3 compatible device defined in the table
below:</p>
<table><tbody><tr>
<td><b>Metric</b></td>
<td><b>Performance Threshold</b></td>
<td><b>Comments</b></td>
</tr>
<tr>
<td>Application Launch Time</td>
<td>The following applications should launch within the specified time.<ul>
<li>Browser: less than 1300ms</li>
<li>MMS/SMS: less than 700ms</li>
<li>AlarmClock: less than 650ms</li>
</ul></td>
<td>The launch time is measured as the total time to
complete loading the default activity for the application, including the time
it takes to start the Linux process, load the Android package into the Dalvik
VM, and call onCreate.</td>
</tr>
<tr>
<td>Simultaneous Applications</td>
<td>When multiple applications have been launched, re-launching an
already-running application after it has been launched must take less than the
original launch time.</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>

<a name="section-9"></a><h2>9. Security Model Compatibility</h2>
<p>Device implementations MUST implement a security model consistent with the
Android platform security model as defined in Security and Permissions
reference document in the APIs [<a href="#resources42">Resources, 42</a>] in the
Android developer documentation. Device implementations MUST support
installation of self-signed applications without requiring any additional
permissions/certificates from any third parties/authorities.  Specifically,
compatible devices MUST support the security mechanisms described in the
follow sub-sections.</p>
<a name="section-9.1"></a><h3>9.1. Permissions</h3>
<p>Device implementations MUST support the Android permissions model as
defined in the Android developer documentation [<a
href="#resources42">Resources, 42</a>]. Specifically,
implementations MUST enforce each permission defined as described in the SDK
documentation; no permissions may be omitted, altered, or ignored.
Implementations MAY add additional permissions, provided the new permission ID
strings are not in the android.* namespace.</p>
<a name="section-9.2"></a><h3>9.2. UID and Process Isolation</h3>
<p>Device implementations MUST support the Android application sandbox model,
in which each application runs as a unique Unix-style UID and in a separate
process.  Device implementations MUST support running multiple applications as
the same Linux user ID, provided that the applications are properly signed and
constructed, as defined in the Security and Permissions reference [<a
href="#resources42">Resources, 42</a>].</p>
<a name="section-9.3"></a><h3>9.3. Filesystem Permissions</h3>
<p>Device implementations MUST support the Android file access permissions
model as defined in as defined in the Security and Permissions reference [<a
href="#resources42">Resources, 42</a>].</p>
<a name="section-9.4"></a><h3>9.4. Alternate Execution Environments</h3>
<p>Device implementations MAY include runtime environments that execute
applications using some other software or technology than the Dalvik virtual
machine or native code. However, such alternate execution environments MUST
NOT compromise the Android security model or the security of installed Android
applications, as described in this section.</p>
<p>Alternate runtimes MUST themselves be Android applications, and abide by
   the standard Android security model, as described elsewhere in Section 9.</p>
<p>Alternate runtimes MUST NOT be granted access to resources protected by
   permissions not requested in the runtime's AndroidManifest.xml file via the
   <code>&lt;uses-permission&gt;</code> mechanism.</p>
<p>Alternate runtimes MUST NOT permit applications to make use of features
   protected by Android permissions restricted to system applications.</p>
<p>Alternate runtimes MUST abide by the Android sandbox model.  Specifically:</p>
<ul>
<li>Alternate runtimes SHOULD install apps via the PackageManager into
    separate Android sandboxes (that is, Linux user IDs, etc.)</li>
<li>Alternate runtimes MAY provide a single Android sandbox shared by all
    applications using the alternate runtime.</li>
<li>Alternate runtimes and installed applications using an alternate runtime
    MUST NOT reuse the sandbox of any other app installed on the device, except
    through the standard Android mechanisms of shared user ID and signing
    certificate</li>
<li>Alternate runtimes MUST NOT launch with, grant, or be granted access to
    the sandboxes corresponding to other Android applications.</li>
</ul>
<p>Alternate runtimes MUST NOT be launched with, be granted, or grant to other
   applications any privileges of the superuser (root), or of any other user ID.</p>
<p>The .apk files of alternate runtimes MAY be included in the system image of
   a device implementation, but MUST be signed with a key distinct
   from the key used to sign other applications included with the device
   implementation.</p>
<p>When installing applications, alternate runtimes MUST obtain user consent
   for the Android permissions used by the application. That is, if an
   application needs to make use of a device resource for which there is a
   corresponding Android permission (such as Camera, GPS, etc.), the alternate
   runtime MUST inform the user that the application will be able to access
   that resource. If the runtime environment does not record application
   capabilities in this manner, the runtime environment MUST list all
   permissions held by the runtime itself when installing any application
   using that runtime.</p>

<a name="section-10"></a><h2>10. Software Compatibility Testing</h2>
<p>The Android Open-Source Project includes various testing tools to verify
that device implementations are compatible. Device implementations MUST pass
all tests described in this section.</p>
<p>However, note that no software test package is fully comprehensive. For
this reason, device implementers are very strongly encouraged to make the
minimum number of changes as possible to the reference and preferred
implementation of Android 2.3 available from the Android Open-Source Project.
This will minimize the risk of introducing bugs that create incompatibilities
requiring rework and potential device updates.</p>
<a name="section-10.1"></a><h3>10.1. Compatibility Test Suite</h3>
<p>Device implementations MUST pass the Android Compatibility Test Suite (CTS)
[<a href="#resources02">Resources, 2</a>] available from the Android Open Source
Project, using the final shipping software on the device. Additionally, device
implementers SHOULD use the reference implementation in the Android Open
Source tree as much as possible, and MUST ensure compatibility in cases of
ambiguity in CTS and for any reimplementations of parts of the reference
source code.</p>
<p>The CTS is designed to be run on an actual device. Like any software, the
CTS may itself contain bugs.  The CTS will be versioned independently of this
Compatibility Definition, and multiple revisions of the CTS may be released
for Android 2.3. Device implementations MUST pass the latest CTS version
available at the time the device software is completed.</p>
<p>MUST pass the most recent version of the Android Compatibility Test Suite
(CTS) available at the time of the device implementation's software is
completed. (The CTS is available as part of the Android Open Source Project [<a
href="#resources02">Resources, 2</a>].) The CTS tests many, but not all, of the
components outlined in this document.</p>
<a name="section-10.2"></a><h3>10.2. CTS Verifier</h3>
<p>Device implementations MUST correctly execute all applicable cases in the
CTS Verifier. The CTS Verifier is included with the Compatibility Test Suite,
and is intended to be run by a human operator to test functionality that
cannot be tested by an automated system, such as correct functioning of a
camera and sensors.</p>
<p>The CTS Verifier has tests for many kinds of hardware, including some
hardware that is optional. Device implementations MUST pass all tests for
hardware which they possess; for instance, if a device possesses an
accelerometer, it MUST correctly execute the Accelerometer test case in the
CTS Verifier. Test cases for features noted as optional by this Compatibility
Definition Document MAY be skipped or omitted.</p>
<p>Every device and every build MUST correctly run the CTS Verifier, as noted
above. However, since many builds are very similar, device implementers are
not expected to explicitly run the CTS Verifier on builds that differ only in
trivial ways. Specifically, device implementations that differ from an
implementation that has passed the CTS Verfier only by the set of included
locales, branding, etc. MAY omit the CTS Verifier test.</p>
<a name="section-10.3"></a><h3>10.3. Reference Applications</h3>
<p>Device implementers MUST test implementation compatibility using the
following open-source applications:</p>
<ul>
<li>The "Apps for Android" applications [<a href="#resources43">Resources, 43</a>].</li>
<li>Replica Island (available in Android Market; only required for device
    implementations that support with OpenGL ES 2.0)</li>
</ul>
<p>Each app above MUST launch and behave correctly on the implementation, for
the implementation to be considered compatible.</p>


<a name="section-11"></a><h2>11. Updatable Software</h2>
<p>Device implementations MUST include a mechanism to replace the entirety of
the system software. The mechanism need not perform "live" upgrades -- that
is, a device restart MAY be required.</p>
<p>Any method can be used, provided that it can replace the entirety of the
software preinstalled on the device. For instance, any of the following
approaches will satisfy this requirement:</p>
<ul>
<li>Over-the-air (OTA) downloads with offline update via reboot</li>
<li>"Tethered" updates over USB from a host PC</li>
<li>"Offline" updates via a reboot and update from a file on removable
storage</li>
</ul>
<p>The update mechanism used MUST support updates without wiping user data.
Note that the upstream Android software includes an update mechanism that
satisfies this requirement.</p>
<p>If an error is found in a device implementation after it has been released
but within its reasonable product lifetime that is determined in consultation
with the Android Compatibility Team to affect the compatibility of third-party
applications, the device implementer MUST correct the error via a software
update available that can be applied per the mechanism just described.</p>

<a name="section-12"></a><h2>12. Contact Us</h2>
<p>You can contact the document authors at <a
href="mailto:compatibility@android.com">compatibility@android.com</a> for
clarifications and to bring up any issues that you think the document does not
cover.</p>

<div style="page-break-before: always;"></div>

<a name="appendix-A"></a><h2>Appendix A - Bluetooth Test Procedure</h2>
<p>The Compatibility Test Suite includes cases that cover basic operation of
the Android RFCOMM Bluetooth API. However, since Bluetooth is a communications
protocol between devices, it cannot be fully tested by unit tests running on a
single device. Consequently, device implementations MUST also pass the
human-operated Bluetooth test procedure described below.</p>
<p>The test procedure is based on the BluetoothChat sample app included in the
Android open-source project tree. The procedure requires two devices:</p>
<ul>
<li>a candidate device implementation running the software build to be tested</li>
<li>a separate device implementation already known to be compatible, and of a
    model from the device implementation being tested -- that is, a "known
    good" device implementation</li>
</ul>
<p>The test procedure below refers to these devices as the "candidate" and "known
good" devices, respectively.</p>
<h3>Setup and Installation</h3>
<ol>
<li>Build BluetoothChat.apk via 'make samples' from an Android source code tree.</li>
<li>Install BluetoothChat.apk on the known-good device.</li>
<li>Install BluetoothChat.apk on the candidate device.</li>
</ol>
<h3>Test Bluetooth Control by Apps</h3>
<ol>
<li>Launch BluetoothChat on the candidate device, while Bluetooth is disabled.</li>
<li>Verify that the candidate device either turns on Bluetooth, or prompts the user with a dialog to turn on Bluetooth.</li>
</ol>
<h3>Test Pairing and Communication</h3>
<ol>
<li>Launch the Bluetooth Chat app on both devices.</li>
<li>Make the known-good device discoverable from within BluetoothChat (using the Menu).</li>
<li>On the candidate device, scan for Bluetooth devices from within BluetoothChat (using the Menu) and pair with the known-good device.</li>
<li>Send 10 or more messages from each device, and verify that the other device receives them correctly.</li>
<li>Close the BluetoothChat app on both devices by pressing <b>Home</b>.</li>
<li>Unpair each device from the other, using the device Settings app.</li>
</ol>
<h3>Test Pairing and Communication in the Reverse Direction</h3>
<ol>
<li>Launch the Bluetooth Chat app on both devices.</li>
<li>Make the candidate device discoverable from within BluetoothChat (using the Menu).</li>
<li>On the known-good device, scan for Bluetooth devices from within BluetoothChat (using the Menu) and pair with the candidate device.</li>
<li>Send 10 or messages from each device, and verify that the other device receives them correctly.</li>
<li>Close the Bluetooth Chat app on both devices by pressing Back repeatedly to get to the Launcher.</li>
</ol>
<h3>Test Re-Launches</h3>
<ol>
<li>Re-launch the Bluetooth Chat app on both devices.</li>
<li>Send 10 or messages from each device, and verify that the other device receives them correctly.</li>
</ol>
<p>Note: the above tests have some cases which end a test section by using
Home, and some using Back. These tests are not redundant and are not optional:
the objective is to verify that the Bluetooth API and stack works correctly
both when Activities are explicitly terminated (via the user pressing Back,
which calls finish()), and implicitly sent to background (via the user
pressing Home.) Each test sequence MUST be performed as described.</p>
<div id="footerContent" xmlns:pdf="http://whatever">
<pdf:pagenumber/>
</div>
</body>
</html>
