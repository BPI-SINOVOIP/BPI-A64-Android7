//
// Copyright (C) 2012 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include "shill/net/rtnl_message.h"

#include <sys/socket.h>
#include <linux/if.h>  // NOLINT(build/include_alpha) - needs sockaddr.
#include <linux/netlink.h>
#include <linux/rtnetlink.h>

#include <string>

#include <gtest/gtest.h>

#include "shill/net/byte_string.h"
#include "shill/net/ip_address.h"

using std::string;
using testing::Test;

namespace shill {

namespace {

// These test strings were generated by cutting up the output of the
// "rtmon" utility into individual strings.  This tool outputs the raw
// RTNL packet contents sent by the kernel.  The comments above each
// of these strings is the markup that the "ip monitor" command
// outputs for each of these RTNL packets.


// 2: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP
//     link/ether c0:f8:da:05:03:0b brd ff:ff:ff:ff:ff:ff

const int kNewLinkMessageWlan0InterfaceIndex = 2;
const unsigned int kNewLinkMessageWlan0InterfaceFlags =
    IFF_BROADCAST | IFF_MULTICAST | IFF_UP | IFF_LOWER_UP | IFF_RUNNING;
const unsigned int kNewLinkMessageWlan0InterfaceFlagsChange = 0;
const uint32_t kNewLinkMessageWlan0MTU = 1500;
const char kNewLinkMessageWlan0MACAddress[] = "\xc0\xf8\xda\x05\x03\x0b";
const char kNewLinkMessageWlan0InterfaceName[] = "wlan0";
const char kNewLinkMessageWlan0Qdisc[] = "mq";
const int kNewLinkMessageWlan0OperState = IF_OPER_UP;

const unsigned char kNewLinkMessageWlan0[] = {
  0xe0, 0x03, 0x00, 0x00, 0x10, 0x00, 0x02, 0x00,
  0x53, 0x18, 0x1f, 0x4e, 0xac, 0x77, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x43, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0a, 0x00, 0x03, 0x00, 0x77, 0x6c, 0x61, 0x6e,
  0x30, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0d, 0x00,
  0xe8, 0x03, 0x00, 0x00, 0x05, 0x00, 0x10, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x11, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00,
  0xdc, 0x05, 0x00, 0x00, 0x07, 0x00, 0x06, 0x00,
  0x6d, 0x71, 0x00, 0x00, 0x20, 0x00, 0x0e, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x01, 0x00,
  0xc0, 0xf8, 0xda, 0x05, 0x03, 0x0b, 0x00, 0x00,
  0x0a, 0x00, 0x02, 0x00, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0x00, 0x00, 0x60, 0x00, 0x07, 0x00,
  0xa6, 0x65, 0x0f, 0x00, 0xa6, 0x0b, 0x00, 0x00,
  0xd2, 0x29, 0x61, 0x06, 0xd7, 0x25, 0x07, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x84, 0x53, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x17, 0x00,
  0xa6, 0x65, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xa6, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xd2, 0x29, 0x61, 0x06, 0x00, 0x00, 0x00, 0x00,
  0xd7, 0x25, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x84, 0x53, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x30, 0x02, 0x1a, 0x00, 0x6c, 0x00, 0x02, 0x00,
  0x68, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xc0, 0x01, 0x0a, 0x00, 0x08, 0x00, 0x01, 0x00,
  0x10, 0x00, 0x00, 0x80, 0x14, 0x00, 0x05, 0x00,
  0xff, 0xff, 0x00, 0x00, 0x22, 0x05, 0x00, 0x00,
  0x4f, 0x53, 0x00, 0x00, 0xe8, 0x03, 0x00, 0x00,
  0x78, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x40, 0x00, 0x00, 0x00, 0xdc, 0x05, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0xa0, 0x0f, 0x00, 0x00,
  0xe8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x80, 0x3a, 0x09, 0x00, 0x80, 0x51, 0x01, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00,
  0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xfc, 0x00, 0x03, 0x00, 0x1f, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x15, 0xe6, 0x04, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x15, 0xe6, 0x04, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x9b, 0x95, 0xb9, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x9b, 0x95, 0xb9, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x18, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x06, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


// Deleted 8: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN
//    link/ether 68:7f:74:ba:ef:c7 brd ff:ff:ff:ff:ff:ff

const int kDelLinkMessageEth0InterfaceIndex = 8;
const unsigned int kDelLinkMessageEth0InterfaceFlags =
    IFF_BROADCAST | IFF_MULTICAST;
const unsigned int kDelLinkMessageEth0InterfaceFlagsChange = 0xffffffff;
const uint32_t kDelLinkMessageEth0MTU = 1500;
const char kDelLinkMessageEth0MACAddress[] = "\x68\x7f\x74\xba\xef\xc7";
const char kDelLinkMessageEth0InterfacName[] = "eth0";
const char kDelLinkMessageEth0Qdisc[] = "noop";
const int kDelLinkMessageEth0OperState = IF_OPER_DOWN;

const unsigned char kDelLinkMessageEth0[] = {
  0xb8, 0x01, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x02, 0x10, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
  0x09, 0x00, 0x03, 0x00, 0x65, 0x74, 0x68, 0x30,
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0d, 0x00,
  0xe8, 0x03, 0x00, 0x00, 0x05, 0x00, 0x10, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x11, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00,
  0xdc, 0x05, 0x00, 0x00, 0x09, 0x00, 0x06, 0x00,
  0x6e, 0x6f, 0x6f, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0a, 0x00, 0x01, 0x00, 0x68, 0x7f, 0x74, 0xba,
  0xef, 0xc7, 0x00, 0x00, 0x0a, 0x00, 0x02, 0x00,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
  0x60, 0x00, 0x07, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x0e, 0x00, 0x00, 0x00, 0xfa, 0x05, 0x00, 0x00,
  0x34, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xbc, 0x00, 0x17, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfa, 0x05, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x34, 0x06, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x15, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x1a, 0x00,
};

// 8: if8    inet 192.168.10.100/24 brd 192.168.10.255 scope global eth0

const int kNewAddrIPV4InterfaceIndex = 8;
const char kNewAddrIPV4Address[] = "192.168.10.100";
const int kNewAddrIPV4AddressPrefix = 24;
const unsigned char kNewAddrIPV4Scope = RT_SCOPE_UNIVERSE;

const unsigned char kNewAddrIPV4[] = {
  0x3c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x18, 0x80, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x01, 0x00, 0xc0, 0xa8, 0x0a, 0x64,
  0x08, 0x00, 0x02, 0x00, 0xc0, 0xa8, 0x0a, 0x64,
  0x08, 0x00, 0x04, 0x00, 0xc0, 0xa8, 0x0a, 0xff,
  0x09, 0x00, 0x03, 0x00, 0x65, 0x74, 0x68, 0x30,
  0x00, 0x00, 0x00, 0x00,
};

// Deleted 15: if15    inet6 fe80::6a7f:74ff:feba:efc7/64 scope link
//       valid_lft forever preferred_lft forever

const int kDelAddrIPV6InterfaceIndex = 15;
const char kDelAddrIPV6Address[] = "fe80::6a7f:74ff:feba:efc7";
const int kDelAddrIPV6AddressPrefix = 64;
const unsigned char kDelAddrIPV6Scope = RT_SCOPE_LINK;

const unsigned char kDelAddrIPV6[] = {
  0x40, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0a, 0x40, 0x80, 0xfd, 0x0f, 0x00, 0x00, 0x00,
  0x14, 0x00, 0x01, 0x00, 0xfe, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x6a, 0x7f, 0x74, 0xff,
  0xfe, 0xba, 0xef, 0xc7, 0x14, 0x00, 0x06, 0x00,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xbf, 0xdb, 0x02, 0x00, 0xbf, 0xdb, 0x02, 0x00,
};

// Deleted ff02::1:ffa0:688 via ff02::1:ffa0:688 dev if2  metric 0

const int kDelRouteIPV6InterfaceIndex = 2;
const char kDelRouteIPV6Address[] = "ff02::1:ffa0:688";
const int kDelRouteIPV6Prefix = 128;
const int kDelRouteIPV6Metric = 0;

const unsigned char kDelRouteIPV6[] = {
  0x80, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0a, 0x80, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x01,
  0x00, 0x02, 0x00, 0x00, 0x08, 0x00, 0x0f, 0x00,
  0xfe, 0x00, 0x00, 0x00, 0x14, 0x00, 0x01, 0x00,
  0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0xff, 0xa0, 0x06, 0x88,
  0x14, 0x00, 0x05, 0x00, 0xff, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xff, 0xa0, 0x06, 0x88, 0x08, 0x00, 0x04, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x06, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x0c, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x5f, 0x0c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// default via 192.168.17.254 dev if12  metric 9

const int kAddRouteIPV4InterfaceIndex = 12;
const char kAddRouteIPV4Address[] = "192.168.17.254";
const int kAddRouteIPV4Metric = 9;

const unsigned char kAddRouteIPV4[] = {
  0x3c, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0xfe, 0x03, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0f, 0x00,
  0xfe, 0x00, 0x00, 0x00, 0x08, 0x00, 0x06, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x05, 0x00,
  0xc0, 0xa8, 0x11, 0xfe, 0x08, 0x00, 0x04, 0x00,
  0x0c, 0x00, 0x00, 0x00,
};


// This is the same as kAddRouteIPV4 above, except manually corrupted
// the second to last parameter
const unsigned char kAddRouteBusted[] = {
  0x3c, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0xfe, 0x03, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0f, 0x00,
  0xfe, 0x00, 0x00, 0x00, 0x08, 0x00, 0x06, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x28, 0x00, 0x05, 0x00,
  0xc0, 0xa8, 0x11, 0xfe, 0x08, 0x00, 0x04, 0x00,
  0x0c, 0x00, 0x00, 0x00,
};

// 192.168.10.1 dev if8 lladdr 00:14:d1:cd:d5:2c REACHABLE
const unsigned char kAddNeighborMessage[] = {
  0x4c, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x01, 0x08, 0x00, 0x01, 0x00,
  0xc0, 0xa8, 0x0a, 0x01, 0x0a, 0x00, 0x02, 0x00,
  0x00, 0x14, 0xd1, 0xcd, 0xd5, 0x2c, 0x00, 0x00,
  0x08, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x14, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00,
};

// RDNSS notification
// Lifetime: infinity (0xffffffff)
// Server addresses: 2001:db8:100:f101::1, 2001:db8:100:f101::2
const unsigned char kNdRdnssMessage[] = {
  0x5c, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0a, 0x00, 0x28, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x86, 0x00, 0x03, 0x00, 0x14, 0x00, 0x01, 0x00,
  0x19, 0x05, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
  0x20, 0x01, 0x0d, 0xb8, 0x01, 0x00, 0xf1, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x20, 0x01, 0x0d, 0xb8, 0x01, 0x00, 0xf1, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x14, 0x00, 0x01, 0x00, 0xfe, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x50, 0xf8, 0x86, 0xff,
};

}  // namespace

class RTNLMessageTest : public Test {
 protected:
  void TestParseLink(const ByteString& packet,
                     RTNLMessage::Mode mode,
                     int interface_index,
                     unsigned int flags,
                     unsigned int change,
                     ByteString address,
                     ByteString name,
                     uint32_t mtu,
                     ByteString qdisc,
                     int oper_state) {
    RTNLMessage msg;
    EXPECT_TRUE(msg.Decode(packet));

    EXPECT_EQ(RTNLMessage::kTypeLink, msg.type());
    EXPECT_EQ(mode, msg.mode());
    EXPECT_EQ(interface_index, msg.interface_index());

    RTNLMessage::LinkStatus status = msg.link_status();
    EXPECT_EQ(flags, status.flags);
    EXPECT_EQ(change, status.change);

    EXPECT_TRUE(msg.HasAttribute(IFLA_ADDRESS));
    EXPECT_EQ(address.GetLength(), msg.GetAttribute(IFLA_ADDRESS).GetLength());
    EXPECT_TRUE(msg.GetAttribute(IFLA_ADDRESS).Equals(address));

    EXPECT_TRUE(msg.HasAttribute(IFLA_IFNAME));
    EXPECT_EQ(name.GetLength(), msg.GetAttribute(IFLA_IFNAME).GetLength());
    EXPECT_TRUE(msg.GetAttribute(IFLA_IFNAME).Equals(name));

    EXPECT_TRUE(msg.HasAttribute(IFLA_MTU));
    uint32_t mtu_val;
    EXPECT_TRUE(msg.GetAttribute(IFLA_MTU).ConvertToCPUUInt32(&mtu_val));
    EXPECT_EQ(mtu, mtu_val);

    EXPECT_TRUE(msg.HasAttribute(IFLA_QDISC));
    EXPECT_EQ(qdisc.GetLength(), msg.GetAttribute(IFLA_QDISC).GetLength());
    EXPECT_TRUE(msg.GetAttribute(IFLA_QDISC).Equals(qdisc));

    EXPECT_TRUE(msg.HasAttribute(IFLA_OPERSTATE));
    EXPECT_EQ(oper_state, msg.GetAttribute(IFLA_OPERSTATE).GetConstData()[0]);
  }

  void TestParseAddress(const ByteString& packet,
                        RTNLMessage::Mode mode,
                        int interface_index,
                        const IPAddress& address,
                        unsigned char scope) {
    RTNLMessage msg;

    EXPECT_TRUE(msg.Decode(packet));
    EXPECT_EQ(RTNLMessage::kTypeAddress, msg.type());
    EXPECT_EQ(mode, msg.mode());
    EXPECT_EQ(interface_index, msg.interface_index());
    EXPECT_EQ(address.family(), msg.family());

    RTNLMessage::AddressStatus status = msg.address_status();
    EXPECT_EQ(scope, status.scope);

    EXPECT_TRUE(msg.HasAttribute(IFA_ADDRESS));
    EXPECT_EQ(address.GetLength(), msg.GetAttribute(IFA_ADDRESS).GetLength());
    EXPECT_TRUE(
        IPAddress(address.family(),
                  msg.GetAttribute(IFA_ADDRESS),
                  status.prefix_len).Equals(address));
  }

  void TestParseRoute(const ByteString& packet,
                      RTNLMessage::Mode /*mode*/,
                      IPAddress::Family family,
                      int interface_index,
                      const IPAddress& dst,
                      const IPAddress& src,
                      const IPAddress& gateway,
                      unsigned char table,
                      int protocol,
                      unsigned char scope,
                      unsigned char type,
                      int metric) {
    RTNLMessage msg;

    EXPECT_TRUE(msg.Decode(packet));
    EXPECT_EQ(RTNLMessage::kTypeRoute, msg.type());
    EXPECT_EQ(0, msg.interface_index());
    EXPECT_EQ(family, msg.family());

    RTNLMessage::RouteStatus status = msg.route_status();
    EXPECT_EQ(table, status.table);
    EXPECT_EQ(protocol, status.protocol);
    EXPECT_EQ(scope, status.scope);
    EXPECT_EQ(type, status.type);

    if (!dst.IsDefault()) {
      EXPECT_TRUE(msg.HasAttribute(RTA_DST));
      EXPECT_TRUE(IPAddress(family,
                            msg.GetAttribute(RTA_DST),
                            status.dst_prefix).Equals(dst));
    }

    if (!src.IsDefault()) {
      EXPECT_TRUE(msg.HasAttribute(RTA_SRC));
      EXPECT_TRUE(IPAddress(family,
                            msg.GetAttribute(RTA_SRC),
                            status.src_prefix).Equals(src));
    }

    if (!gateway.IsDefault()) {
      EXPECT_TRUE(msg.HasAttribute(RTA_GATEWAY));
      EXPECT_TRUE(IPAddress(family,
                            msg.GetAttribute(RTA_GATEWAY)).Equals(gateway));
    }

    if (interface_index >= 0) {
      EXPECT_TRUE(msg.HasAttribute(RTA_OIF));
      uint32_t int_val;
      EXPECT_TRUE(msg.GetAttribute(RTA_OIF).ConvertToCPUUInt32(&int_val));
      EXPECT_EQ(interface_index, int_val);
    } else {
      EXPECT_FALSE(msg.HasAttribute(RTA_OIF));
    }
    if (metric >= 0) {
      EXPECT_TRUE(msg.HasAttribute(RTA_PRIORITY));
      uint32_t metric_val;
      EXPECT_TRUE(
          msg.GetAttribute(RTA_PRIORITY).ConvertToCPUUInt32(&metric_val));
      EXPECT_EQ(metric, metric_val);
    } else {
      EXPECT_FALSE(msg.HasAttribute(RTA_PRIORITY));
    }
  }

  void TestParseRdnss(const ByteString& packet,
                      RTNLMessage::Mode mode,
                      int interface_index,
                      uint32_t lifetime,
                      const std::string& dns_server_addresses) {
    RTNLMessage msg;

    EXPECT_TRUE(msg.Decode(packet));
    EXPECT_EQ(RTNLMessage::kTypeRdnss, msg.type());
    EXPECT_EQ(mode, msg.mode());
    EXPECT_EQ(interface_index, msg.interface_index());

    RTNLMessage::RdnssOption rdnss = msg.rdnss_option();

    // Format addresses string for verification.
    std::string addresses;
    bool first = true;
    for (auto& ip : rdnss.addresses) {
      if (!first) {
        addresses += ", ";
      } else {
        first = false;
      }
      addresses += ip.ToString();
    }

    // Verify life time and addresses.
    EXPECT_EQ(lifetime, rdnss.lifetime);
    EXPECT_EQ(dns_server_addresses, addresses);
  }

  void TestParseNeighbor(const ByteString& packet,
                         RTNLMessage::Mode mode,
                         IPAddress::Family family,
                         int interface_index,
                         uint16_t state,
                         uint8_t flags,
                         uint8_t type) {
    RTNLMessage msg;

    EXPECT_TRUE(msg.Decode(packet));
    EXPECT_EQ(RTNLMessage::kTypeNeighbor, msg.type());
    EXPECT_EQ(mode, msg.mode());
    EXPECT_EQ(family, msg.family());
    EXPECT_EQ(interface_index, msg.interface_index());

    RTNLMessage::NeighborStatus neighbor = msg.neighbor_status();

    EXPECT_EQ(neighbor.state, state);
    EXPECT_EQ(neighbor.flags, flags);
    EXPECT_EQ(neighbor.type, type);
  }
};

TEST_F(RTNLMessageTest, NewLinkWlan0) {
  TestParseLink(ByteString(kNewLinkMessageWlan0, sizeof(kNewLinkMessageWlan0)),
                RTNLMessage::kModeAdd,
                kNewLinkMessageWlan0InterfaceIndex,
                kNewLinkMessageWlan0InterfaceFlags,
                kNewLinkMessageWlan0InterfaceFlagsChange,
                ByteString(string(kNewLinkMessageWlan0MACAddress), false),
                ByteString(string(kNewLinkMessageWlan0InterfaceName), true),
                kNewLinkMessageWlan0MTU,
                ByteString(string(kNewLinkMessageWlan0Qdisc), true),
                kNewLinkMessageWlan0OperState);
}

TEST_F(RTNLMessageTest, DelLinkEth0) {
  TestParseLink(ByteString(kDelLinkMessageEth0, sizeof(kDelLinkMessageEth0)),
                RTNLMessage::kModeDelete,
                kDelLinkMessageEth0InterfaceIndex,
                kDelLinkMessageEth0InterfaceFlags,
                kDelLinkMessageEth0InterfaceFlagsChange,
                ByteString(string(kDelLinkMessageEth0MACAddress), false),
                ByteString(string(kDelLinkMessageEth0InterfacName), true),
                kDelLinkMessageEth0MTU,
                ByteString(string(kDelLinkMessageEth0Qdisc), true),
                kDelLinkMessageEth0OperState);
}

TEST_F(RTNLMessageTest, NewAddrIPv4) {
  IPAddress addr(IPAddress::kFamilyIPv4);

  EXPECT_TRUE(addr.SetAddressFromString(kNewAddrIPV4Address));
  addr.set_prefix(kNewAddrIPV4AddressPrefix);
  TestParseAddress(ByteString(kNewAddrIPV4, sizeof(kNewAddrIPV4)),
                   RTNLMessage::kModeAdd,
                   kNewAddrIPV4InterfaceIndex,
                   addr,
                   kNewAddrIPV4Scope);
}

TEST_F(RTNLMessageTest, DelAddrIPv6) {
  IPAddress addr(IPAddress::kFamilyIPv6);

  EXPECT_TRUE(addr.SetAddressFromString(kDelAddrIPV6Address));
  addr.set_prefix(kDelAddrIPV6AddressPrefix);
  TestParseAddress(ByteString(kDelAddrIPV6, sizeof(kDelAddrIPV6)),
                   RTNLMessage::kModeDelete,
                   kDelAddrIPV6InterfaceIndex,
                   addr,
                   kDelAddrIPV6Scope);
}

TEST_F(RTNLMessageTest, DelRouteIPv6) {
  IPAddress dst(IPAddress::kFamilyIPv6);
  IPAddress src(IPAddress::kFamilyIPv6);
  IPAddress gateway(IPAddress::kFamilyIPv6);

  EXPECT_TRUE(dst.SetAddressFromString(kDelRouteIPV6Address));
  dst.set_prefix(kDelRouteIPV6Prefix);
  src.SetAddressToDefault();
  EXPECT_TRUE(gateway.SetAddressFromString(kDelRouteIPV6Address));

  TestParseRoute(ByteString(kDelRouteIPV6, sizeof(kDelRouteIPV6)),
                 RTNLMessage::kModeDelete,
                 IPAddress::kFamilyIPv6,
                 kDelRouteIPV6InterfaceIndex,
                 dst,
                 src,
                 gateway,
                 RT_TABLE_MAIN,
                 RTPROT_UNSPEC,
                 RT_SCOPE_UNIVERSE,
                 RTN_UNICAST,
                 kDelRouteIPV6Metric);
}

TEST_F(RTNLMessageTest, AddRouteIPv4) {
  IPAddress dst(IPAddress::kFamilyIPv4);
  IPAddress src(IPAddress::kFamilyIPv4);
  IPAddress gateway(IPAddress::kFamilyIPv4);

  dst.SetAddressToDefault();
  src.SetAddressToDefault();
  EXPECT_TRUE(gateway.SetAddressFromString(kAddRouteIPV4Address));

  TestParseRoute(ByteString(kAddRouteIPV4, sizeof(kAddRouteIPV4)),
                 RTNLMessage::kModeAdd,
                 IPAddress::kFamilyIPv4,
                 kAddRouteIPV4InterfaceIndex,
                 dst,
                 src,
                 gateway,
                 RT_TABLE_MAIN,
                 RTPROT_BOOT,
                 RT_SCOPE_UNIVERSE,
                 RTN_UNICAST,
                 kAddRouteIPV4Metric);
}

TEST_F(RTNLMessageTest, NewRdnssOption) {
  int interface_index = 1;
  uint32_t lifetime = 0xffffffff;
  std::string dns_server_addresses =
      "2001:db8:100:f101::1, 2001:db8:100:f101::2";

  TestParseRdnss(ByteString(kNdRdnssMessage, sizeof(kNdRdnssMessage)),
                 RTNLMessage::kModeAdd,
                 interface_index,
                 lifetime,
                 dns_server_addresses);
}

TEST_F(RTNLMessageTest, AddRouteBusted) {
  // RTNLMessage should list parse errors as kMessageUnknown
  RTNLMessage msg;
  EXPECT_FALSE(msg.Decode(
      ByteString(kAddRouteBusted, sizeof(kAddRouteBusted))));
}

TEST_F(RTNLMessageTest, AddNeighbor) {
  TestParseNeighbor(
      ByteString(kAddNeighborMessage, sizeof(kAddNeighborMessage)),
      RTNLMessage::kModeAdd,
      IPAddress::kFamilyIPv4,
      8,
      NUD_REACHABLE,
      0,
      NDA_DST);
}

TEST_F(RTNLMessageTest, EncodeDelNeighbor) {
  RTNLMessage msg(RTNLMessage::kTypeNeighbor,
                  RTNLMessage::kModeDelete,
                  0, 1, 2, 0,
                  IPAddress::kFamilyIPv4);
  msg.set_neighbor_status(RTNLMessage::NeighborStatus(
      0, NTF_ROUTER, NDA_LLADDR));

  TestParseNeighbor(msg.Encode(),
                    RTNLMessage::kModeDelete,
                    IPAddress::kFamilyIPv4,
                    0,
                    0,
                    NTF_ROUTER,
                    NDA_LLADDR);
}

TEST_F(RTNLMessageTest, EncodeRouteAdd) {
  RTNLMessage msg(RTNLMessage::kTypeRoute,
                  RTNLMessage::kModeAdd,
                  0, 1, 2, 0,
                  IPAddress::kFamilyIPv4);
  IPAddress dst(IPAddress::kFamilyIPv4);
  IPAddress src(IPAddress::kFamilyIPv4);
  IPAddress gateway(IPAddress::kFamilyIPv4);

  dst.SetAddressToDefault();
  src.SetAddressToDefault();
  EXPECT_TRUE(gateway.SetAddressFromString("192.168.0.1"));

  msg.set_route_status(RTNLMessage::RouteStatus(
      0, 0, RT_TABLE_MAIN, RTPROT_BOOT, RT_SCOPE_UNIVERSE, RTN_UNICAST, 0));
  msg.SetAttribute(RTA_DST, dst.address());
  msg.SetAttribute(RTA_SRC, src.address());
  msg.SetAttribute(RTA_GATEWAY, gateway.address());
  msg.SetAttribute(RTA_OIF, ByteString::CreateFromCPUUInt32(12));
  msg.SetAttribute(RTA_PRIORITY, ByteString::CreateFromCPUUInt32(13));

  TestParseRoute(msg.Encode(),
                 RTNLMessage::kModeAdd,
                 IPAddress::kFamilyIPv4,
                 12,
                 dst,
                 src,
                 gateway,
                 RT_TABLE_MAIN,
                 RTPROT_BOOT,
                 RT_SCOPE_UNIVERSE,
                 RTN_UNICAST,
                 13);
}

TEST_F(RTNLMessageTest, EncodeLinkDel) {
  const int kInterfaceIndex = 0x1234;
  RTNLMessage pmsg(RTNLMessage::kTypeLink,
                  RTNLMessage::kModeDelete,
                  NLM_F_REQUEST,
                  0,
                  0,
                  kInterfaceIndex,
                  IPAddress::kFamilyUnknown);

  RTNLMessage msg;
  EXPECT_TRUE(msg.Decode(pmsg.Encode()));

  EXPECT_EQ(RTNLMessage::kTypeLink, msg.type());
  EXPECT_EQ(RTNLMessage::kModeDelete, msg.mode());
  EXPECT_EQ(kInterfaceIndex, msg.interface_index());

  RTNLMessage::LinkStatus status = msg.link_status();
  EXPECT_EQ(0, status.flags);
  EXPECT_EQ(0, status.change);

  EXPECT_FALSE(msg.HasAttribute(IFLA_ADDRESS));
  EXPECT_FALSE(msg.HasAttribute(IFLA_IFNAME));
  EXPECT_FALSE(msg.HasAttribute(IFLA_MTU));
  EXPECT_FALSE(msg.HasAttribute(IFLA_QDISC));
  EXPECT_FALSE(msg.HasAttribute(IFLA_OPERSTATE));
}

}  // namespace shill
