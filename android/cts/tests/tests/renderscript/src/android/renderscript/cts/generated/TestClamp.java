/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Don't edit this file!  It is auto-generated by frameworks/rs/api/generate.sh.

package android.renderscript.cts;

import android.renderscript.Allocation;
import android.renderscript.RSRuntimeException;
import android.renderscript.Element;
import android.renderscript.cts.Target;

import java.util.Arrays;

public class TestClamp extends RSBaseCompute {

    private ScriptC_TestClamp script;
    private ScriptC_TestClampRelaxed scriptRelaxed;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        script = new ScriptC_TestClamp(mRS);
        scriptRelaxed = new ScriptC_TestClampRelaxed(mRS);
    }

    public class ArgumentsFloatFloatFloatFloat {
        public float inValue;
        public float inMinValue;
        public float inMaxValue;
        public Target.Floaty out;
    }

    private void checkClampFloatFloatFloatFloat() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xc83c447dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x30234027l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xc180322dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloatFloatFloatFloat(inValue, out);
            verifyResultsClampFloatFloatFloatFloat(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloatFloatFloatFloat: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloatFloatFloatFloat(inValue, out);
            verifyResultsClampFloatFloatFloatFloat(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloatFloatFloatFloat: " + e.toString());
        }
    }

    private void verifyResultsClampFloatFloatFloatFloat(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 1 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (!args.out.couldBe(arrayOut[i * 1 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloatFloatFloatFloat" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat2Float2Float2Float2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x142b07a5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0xea8fc01fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x7becb225l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat2Float2Float2Float2(inValue, out);
            verifyResultsClampFloat2Float2Float2Float2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2Float2Float2Float2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat2Float2Float2Float2(inValue, out);
            verifyResultsClampFloat2Float2Float2Float2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2Float2Float2Float2: " + e.toString());
        }
    }

    private void verifyResultsClampFloat2Float2Float2Float2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat2Float2Float2Float2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat3Float3Float3Float3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x30ad7481l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x3946aa73l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0xcaa39c79l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat3Float3Float3Float3(inValue, out);
            verifyResultsClampFloat3Float3Float3Float3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3Float3Float3Float3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat3Float3Float3Float3(inValue, out);
            verifyResultsClampFloat3Float3Float3Float3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3Float3Float3Float3: " + e.toString());
        }
    }

    private void verifyResultsClampFloat3Float3Float3Float3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat3Float3Float3Float3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat4Float4Float4Float4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x4d2fe15dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x87fd94c7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x195a86cdl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat4Float4Float4Float4(inValue, out);
            verifyResultsClampFloat4Float4Float4Float4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4Float4Float4Float4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat4Float4Float4Float4(inValue, out);
            verifyResultsClampFloat4Float4Float4Float4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4Float4Float4Float4: " + e.toString());
        }
    }

    private void verifyResultsClampFloat4Float4Float4Float4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat4Float4Float4Float4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat2FloatFloatFloat2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0xf1fca1a1l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x1a6253d3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xabbf45d9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat2FloatFloatFloat2(inValue, out);
            verifyResultsClampFloat2FloatFloatFloat2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2FloatFloatFloat2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat2FloatFloatFloat2(inValue, out);
            verifyResultsClampFloat2FloatFloatFloat2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2FloatFloatFloat2: " + e.toString());
        }
    }

    private void verifyResultsClampFloat2FloatFloatFloat2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat2FloatFloatFloat2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat3FloatFloatFloat3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x6ab8cf27l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x4d90bbc5l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xdeedadcbl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat3FloatFloatFloat3(inValue, out);
            verifyResultsClampFloat3FloatFloatFloat3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3FloatFloatFloat3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat3FloatFloatFloat3(inValue, out);
            verifyResultsClampFloat3FloatFloatFloat3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3FloatFloatFloat3: " + e.toString());
        }
    }

    private void verifyResultsClampFloat3FloatFloatFloat3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat3FloatFloatFloat3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat4FloatFloatFloat4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0xe374fcadl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x80bf23b7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x121c15bdl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat4FloatFloatFloat4(inValue, out);
            verifyResultsClampFloat4FloatFloatFloat4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4FloatFloatFloat4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat4FloatFloatFloat4(inValue, out);
            verifyResultsClampFloat4FloatFloatFloat4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4FloatFloatFloat4: " + e.toString());
        }
    }

    private void verifyResultsClampFloat4FloatFloatFloat4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat4FloatFloatFloat4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsCharCharCharChar {
        public byte inValue;
        public byte inMinValue;
        public byte inMaxValue;
        public byte out;
    }

    private void checkClampCharCharCharChar() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xb673cf75l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x3c505c8fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xcdad4e95l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampCharCharCharChar(inValue, out);
            verifyResultsClampCharCharCharChar(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampCharCharCharChar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampCharCharCharChar(inValue, out);
            verifyResultsClampCharCharCharChar(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampCharCharCharChar: " + e.toString());
        }
    }

    private void verifyResultsClampCharCharCharChar(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampCharCharCharChar" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar2Char2Char2Char2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0xc3feb45dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x3442bdc7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0xc59fafcdl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar2Char2Char2Char2(inValue, out);
            verifyResultsClampChar2Char2Char2Char2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2Char2Char2Char2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar2Char2Char2Char2(inValue, out);
            verifyResultsClampChar2Char2Char2Char2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2Char2Char2Char2: " + e.toString());
        }
    }

    private void verifyResultsClampChar2Char2Char2Char2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar2Char2Char2Char2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar3Char3Char3Char3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0xb9d3b0a5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x470ecb1fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0xd86bbd25l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar3Char3Char3Char3(inValue, out);
            verifyResultsClampChar3Char3Char3Char3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3Char3Char3Char3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar3Char3Char3Char3(inValue, out);
            verifyResultsClampChar3Char3Char3Char3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3Char3Char3Char3: " + e.toString());
        }
    }

    private void verifyResultsClampChar3Char3Char3Char3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar3Char3Char3Char3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar4Char4Char4Char4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xafa8acedl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0x59dad877l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xeb37ca7dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar4Char4Char4Char4(inValue, out);
            verifyResultsClampChar4Char4Char4Char4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4Char4Char4Char4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar4Char4Char4Char4(inValue, out);
            verifyResultsClampChar4Char4Char4Char4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4Char4Char4Char4: " + e.toString());
        }
    }

    private void verifyResultsClampChar4Char4Char4Char4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar4Char4Char4Char4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUcharUcharUcharUchar {
        public byte inValue;
        public byte inMinValue;
        public byte inMaxValue;
        public byte out;
    }

    private void checkClampUcharUcharUcharUchar() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xa4447655l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x75336f2fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x6906135l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUcharUcharUcharUchar(inValue, out);
            verifyResultsClampUcharUcharUcharUchar(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUcharUcharUcharUchar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUcharUcharUcharUchar(inValue, out);
            verifyResultsClampUcharUcharUcharUchar(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUcharUcharUcharUchar: " + e.toString());
        }
    }

    private void verifyResultsClampUcharUcharUcharUchar(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUcharUcharUcharUchar" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar2Uchar2Uchar2Uchar2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0x45dae301l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0x662c1df3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xf7890ff9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar2Uchar2Uchar2Uchar2(inValue, out);
            verifyResultsClampUchar2Uchar2Uchar2Uchar2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2Uchar2Uchar2Uchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar2Uchar2Uchar2Uchar2(inValue, out);
            verifyResultsClampUchar2Uchar2Uchar2Uchar2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2Uchar2Uchar2Uchar2: " + e.toString());
        }
    }

    private void verifyResultsClampUchar2Uchar2Uchar2Uchar2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar2Uchar2Uchar2Uchar2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar3Uchar3Uchar3Uchar3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x625d4fddl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0xb4e30847l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x463ffa4dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar3Uchar3Uchar3Uchar3(inValue, out);
            verifyResultsClampUchar3Uchar3Uchar3Uchar3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3Uchar3Uchar3Uchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar3Uchar3Uchar3Uchar3(inValue, out);
            verifyResultsClampUchar3Uchar3Uchar3Uchar3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3Uchar3Uchar3Uchar3: " + e.toString());
        }
    }

    private void verifyResultsClampUchar3Uchar3Uchar3Uchar3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar3Uchar3Uchar3Uchar3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar4Uchar4Uchar4Uchar4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x7edfbcb9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x399f29bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x94f6e4a1l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar4Uchar4Uchar4Uchar4(inValue, out);
            verifyResultsClampUchar4Uchar4Uchar4Uchar4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4Uchar4Uchar4Uchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar4Uchar4Uchar4Uchar4(inValue, out);
            verifyResultsClampUchar4Uchar4Uchar4Uchar4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4Uchar4Uchar4Uchar4: " + e.toString());
        }
    }

    private void verifyResultsClampUchar4Uchar4Uchar4Uchar4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar4Uchar4Uchar4Uchar4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsShortShortShortShort {
        public short inValue;
        public short inMinValue;
        public short inMaxValue;
        public short out;
    }

    private void checkClampShortShortShortShort() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x7fc993ddl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xb4661447l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x45c3064dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShortShortShortShort(inValue, out);
            verifyResultsClampShortShortShortShort(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShortShortShortShort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShortShortShortShort(inValue, out);
            verifyResultsClampShortShortShortShort(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShortShortShortShort: " + e.toString());
        }
    }

    private void verifyResultsClampShortShortShortShort(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShortShortShortShort" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort2Short2Short2Short2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x984e0915l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x2e67336fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0xbfc42575l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort2Short2Short2Short2(inValue, out);
            verifyResultsClampShort2Short2Short2Short2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2Short2Short2Short2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort2Short2Short2Short2(inValue, out);
            verifyResultsClampShort2Short2Short2Short2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2Short2Short2Short2: " + e.toString());
        }
    }

    private void verifyResultsClampShort2Short2Short2Short2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort2Short2Short2Short2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort3Short3Short3Short3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0xb4d075f1l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x7d1e1dc3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0xe7b0fc9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort3Short3Short3Short3(inValue, out);
            verifyResultsClampShort3Short3Short3Short3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3Short3Short3Short3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort3Short3Short3Short3(inValue, out);
            verifyResultsClampShort3Short3Short3Short3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3Short3Short3Short3: " + e.toString());
        }
    }

    private void verifyResultsClampShort3Short3Short3Short3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort3Short3Short3Short3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort4Short4Short4Short4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xd152e2cdl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xcbd50817l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0x5d31fa1dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort4Short4Short4Short4(inValue, out);
            verifyResultsClampShort4Short4Short4Short4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4Short4Short4Short4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort4Short4Short4Short4(inValue, out);
            verifyResultsClampShort4Short4Short4Short4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4Short4Short4Short4: " + e.toString());
        }
    }

    private void verifyResultsClampShort4Short4Short4Short4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort4Short4Short4Short4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUshortUshortUshortUshort {
        public short inValue;
        public short inMinValue;
        public short inMaxValue;
        public short out;
    }

    private void checkClampUshortUshortUshortUshort() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xf74c4341l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x94d3e2b3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x2630d4b9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshortUshortUshortUshort(inValue, out);
            verifyResultsClampUshortUshortUshortUshort(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshortUshortUshortUshort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshortUshortUshortUshort(inValue, out);
            verifyResultsClampUshortUshortUshortUshort(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshortUshortUshortUshort: " + e.toString());
        }
    }

    private void verifyResultsClampUshortUshortUshortUshort(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshortUshortUshortUshort" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort2Ushort2Ushort2Ushort2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0xfc36b705l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x4fa3b43fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0xe100a645l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort2Ushort2Ushort2Ushort2(inValue, out);
            verifyResultsClampUshort2Ushort2Ushort2Ushort2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2Ushort2Ushort2Ushort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort2Ushort2Ushort2Ushort2(inValue, out);
            verifyResultsClampUshort2Ushort2Ushort2Ushort2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2Ushort2Ushort2Ushort2: " + e.toString());
        }
    }

    private void verifyResultsClampUshort2Ushort2Ushort2Ushort2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort2Ushort2Ushort2Ushort2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort3Ushort3Ushort3Ushort3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0xfc64ee3dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x610b3967l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0xf2682b6dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort3Ushort3Ushort3Ushort3(inValue, out);
            verifyResultsClampUshort3Ushort3Ushort3Ushort3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3Ushort3Ushort3Ushort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort3Ushort3Ushort3Ushort3(inValue, out);
            verifyResultsClampUshort3Ushort3Ushort3Ushort3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3Ushort3Ushort3Ushort3: " + e.toString());
        }
    }

    private void verifyResultsClampUshort3Ushort3Ushort3Ushort3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort3Ushort3Ushort3Ushort3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort4Ushort4Ushort4Ushort4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xfc932575l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0x7272be8fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0x3cfb095l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort4Ushort4Ushort4Ushort4(inValue, out);
            verifyResultsClampUshort4Ushort4Ushort4Ushort4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4Ushort4Ushort4Ushort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort4Ushort4Ushort4Ushort4(inValue, out);
            verifyResultsClampUshort4Ushort4Ushort4Ushort4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4Ushort4Ushort4Ushort4: " + e.toString());
        }
    }

    private void verifyResultsClampUshort4Ushort4Ushort4Ushort4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort4Ushort4Ushort4Ushort4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsIntIntIntInt {
        public int inValue;
        public int inMinValue;
        public int inMaxValue;
        public int out;
    }

    private void checkClampIntIntIntInt() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xbe6164c5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x7c8bf97fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xde8eb85l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampIntIntIntInt(inValue, out);
            verifyResultsClampIntIntIntInt(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampIntIntIntInt: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampIntIntIntInt(inValue, out);
            verifyResultsClampIntIntIntInt(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampIntIntIntInt: " + e.toString());
        }
    }

    private void verifyResultsClampIntIntIntInt(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampIntIntIntInt" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt2Int2Int2Int2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0xbd307c01l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x9398f8f3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x24f5eaf9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt2Int2Int2Int2(inValue, out);
            verifyResultsClampInt2Int2Int2Int2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2Int2Int2Int2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt2Int2Int2Int2(inValue, out);
            verifyResultsClampInt2Int2Int2Int2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2Int2Int2Int2: " + e.toString());
        }
    }

    private void verifyResultsClampInt2Int2Int2Int2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt2Int2Int2Int2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt3Int3Int3Int3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x5600d2edl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x9c7caa77l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x2dd99c7dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt3Int3Int3Int3(inValue, out);
            verifyResultsClampInt3Int3Int3Int3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3Int3Int3Int3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt3Int3Int3Int3(inValue, out);
            verifyResultsClampInt3Int3Int3Int3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3Int3Int3Int3: " + e.toString());
        }
    }

    private void verifyResultsClampInt3Int3Int3Int3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt3Int3Int3Int3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt4Int4Int4Int4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0xeed129d9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0xa5605bfbl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x36bd4e01l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt4Int4Int4Int4(inValue, out);
            verifyResultsClampInt4Int4Int4Int4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4Int4Int4Int4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt4Int4Int4Int4(inValue, out);
            verifyResultsClampInt4Int4Int4Int4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4Int4Int4Int4: " + e.toString());
        }
    }

    private void verifyResultsClampInt4Int4Int4Int4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt4Int4Int4Int4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUintUintUintUint {
        public int inValue;
        public int inMinValue;
        public int inMaxValue;
        public int out;
    }

    private void checkClampUintUintUintUint() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xefc89475l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xce8b7b8fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x5fe86d95l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUintUintUintUint(inValue, out);
            verifyResultsClampUintUintUintUint(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUintUintUintUint: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUintUintUintUint(inValue, out);
            verifyResultsClampUintUintUintUint(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUintUintUintUint: " + e.toString());
        }
    }

    private void verifyResultsClampUintUintUintUint(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUintUintUintUint" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint2Uint2Uint2Uint2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0x8873ae5dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xaa2a4bc7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0x3b873dcdl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint2Uint2Uint2Uint2(inValue, out);
            verifyResultsClampUint2Uint2Uint2Uint2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2Uint2Uint2Uint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint2Uint2Uint2Uint2(inValue, out);
            verifyResultsClampUint2Uint2Uint2Uint2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2Uint2Uint2Uint2: " + e.toString());
        }
    }

    private void verifyResultsClampUint2Uint2Uint2Uint2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint2Uint2Uint2Uint2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint3Uint3Uint3Uint3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x7e48aaa5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0xbcf6591fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x4e534b25l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint3Uint3Uint3Uint3(inValue, out);
            verifyResultsClampUint3Uint3Uint3Uint3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3Uint3Uint3Uint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint3Uint3Uint3Uint3(inValue, out);
            verifyResultsClampUint3Uint3Uint3Uint3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3Uint3Uint3Uint3: " + e.toString());
        }
    }

    private void verifyResultsClampUint3Uint3Uint3Uint3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint3Uint3Uint3Uint3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint4Uint4Uint4Uint4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x741da6edl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0xcfc26677l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x611f587dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint4Uint4Uint4Uint4(inValue, out);
            verifyResultsClampUint4Uint4Uint4Uint4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4Uint4Uint4Uint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint4Uint4Uint4Uint4(inValue, out);
            verifyResultsClampUint4Uint4Uint4Uint4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4Uint4Uint4Uint4: " + e.toString());
        }
    }

    private void verifyResultsClampUint4Uint4Uint4Uint4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint4Uint4Uint4Uint4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsLongLongLongLong {
        public long inValue;
        public long inMinValue;
        public long inMaxValue;
        public long out;
    }

    private void checkClampLongLongLongLong() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x31c9c41dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x24ef4907l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0xb64c3b0dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLongLongLongLong(inValue, out);
            verifyResultsClampLongLongLongLong(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLongLongLongLong: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLongLongLongLong(inValue, out);
            verifyResultsClampLongLongLongLong(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLongLongLongLong: " + e.toString());
        }
    }

    private void verifyResultsClampLongLongLongLong(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLongLongLongLong" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong2Long2Long2Long2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0xc2b0f12dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0x4a3f8937l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0xdb9c7b3dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong2Long2Long2Long2(inValue, out);
            verifyResultsClampLong2Long2Long2Long2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong2Long2Long2Long2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong2Long2Long2Long2(inValue, out);
            verifyResultsClampLong2Long2Long2Long2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong2Long2Long2Long2: " + e.toString());
        }
    }

    private void verifyResultsClampLong2Long2Long2Long2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong2Long2Long2Long2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong3Long3Long3Long3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0xb885ed75l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0x5d0b968fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0xee688895l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong3Long3Long3Long3(inValue, out);
            verifyResultsClampLong3Long3Long3Long3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong3Long3Long3Long3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong3Long3Long3Long3(inValue, out);
            verifyResultsClampLong3Long3Long3Long3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong3Long3Long3Long3: " + e.toString());
        }
    }

    private void verifyResultsClampLong3Long3Long3Long3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong3Long3Long3Long3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong4Long4Long4Long4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0xae5ae9bdl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0x6fd7a3e7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0x13495edl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong4Long4Long4Long4(inValue, out);
            verifyResultsClampLong4Long4Long4Long4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong4Long4Long4Long4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong4Long4Long4Long4(inValue, out);
            verifyResultsClampLong4Long4Long4Long4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong4Long4Long4Long4: " + e.toString());
        }
    }

    private void verifyResultsClampLong4Long4Long4Long4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong4Long4Long4Long4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUlongUlongUlongUlong {
        public long inValue;
        public long inMinValue;
        public long inMaxValue;
        public long out;
    }

    private void checkClampUlongUlongUlongUlong() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x749bf4c5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0xa8ca97fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x9be99b85l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlongUlongUlongUlong(inValue, out);
            verifyResultsClampUlongUlongUlongUlong(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlongUlongUlongUlong: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlongUlongUlongUlong(inValue, out);
            verifyResultsClampUlongUlongUlongUlong(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlongUlongUlongUlong: " + e.toString());
        }
    }

    private void verifyResultsClampUlongUlongUlongUlong(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlongUlongUlongUlong" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong2Ulong2Ulong2Ulong2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0xa09bb299l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0xfe45623bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0x8fa25441l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong2Ulong2Ulong2Ulong2(inValue, out);
            verifyResultsClampUlong2Ulong2Ulong2Ulong2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong2Ulong2Ulong2Ulong2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong2Ulong2Ulong2Ulong2(inValue, out);
            verifyResultsClampUlong2Ulong2Ulong2Ulong2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong2Ulong2Ulong2Ulong2: " + e.toString());
        }
    }

    private void verifyResultsClampUlong2Ulong2Ulong2Ulong2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong2Ulong2Ulong2Ulong2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong3Ulong3Ulong3Ulong3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0xbd1e1f75l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0x4cfc4c8fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0xde593e95l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong3Ulong3Ulong3Ulong3(inValue, out);
            verifyResultsClampUlong3Ulong3Ulong3Ulong3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong3Ulong3Ulong3Ulong3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong3Ulong3Ulong3Ulong3(inValue, out);
            verifyResultsClampUlong3Ulong3Ulong3Ulong3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong3Ulong3Ulong3Ulong3: " + e.toString());
        }
    }

    private void verifyResultsClampUlong3Ulong3Ulong3Ulong3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong3Ulong3Ulong3Ulong3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong4Ulong4Ulong4Ulong4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0xd9a08c51l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x9bb336e3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x2d1028e9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong4Ulong4Ulong4Ulong4(inValue, out);
            verifyResultsClampUlong4Ulong4Ulong4Ulong4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong4Ulong4Ulong4Ulong4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong4Ulong4Ulong4Ulong4(inValue, out);
            verifyResultsClampUlong4Ulong4Ulong4Ulong4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong4Ulong4Ulong4Ulong4: " + e.toString());
        }
    }

    private void verifyResultsClampUlong4Ulong4Ulong4Ulong4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong4Ulong4Ulong4Ulong4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar2CharCharChar2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x7c57a5d1l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xc3b7db63l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x5514cd69l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar2CharCharChar2(inValue, out);
            verifyResultsClampChar2CharCharChar2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2CharCharChar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar2CharCharChar2(inValue, out);
            verifyResultsClampChar2CharCharChar2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2CharCharChar2: " + e.toString());
        }
    }

    private void verifyResultsClampChar2CharCharChar2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar2CharCharChar2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar3CharCharChar3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x65a26ee5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x492789dfl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xda847be5l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar3CharCharChar3(inValue, out);
            verifyResultsClampChar3CharCharChar3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3CharCharChar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar3CharCharChar3(inValue, out);
            verifyResultsClampChar3CharCharChar3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3CharCharChar3: " + e.toString());
        }
    }

    private void verifyResultsClampChar3CharCharChar3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar3CharCharChar3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar4CharCharChar4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0x4eed37f9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xce97385bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x5ff42a61l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar4CharCharChar4(inValue, out);
            verifyResultsClampChar4CharCharChar4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4CharCharChar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar4CharCharChar4(inValue, out);
            verifyResultsClampChar4CharCharChar4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4CharCharChar4: " + e.toString());
        }
    }

    private void verifyResultsClampChar4CharCharChar4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar4CharCharChar4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar2UcharUcharUchar2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xf02e0d63l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xe9402039l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x7a9d123fl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar2UcharUcharUchar2(inValue, out);
            verifyResultsClampUchar2UcharUcharUchar2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2UcharUcharUchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar2UcharUcharUchar2(inValue, out);
            verifyResultsClampUchar2UcharUcharUchar2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2UcharUcharUchar2: " + e.toString());
        }
    }

    private void verifyResultsClampUchar2UcharUcharUchar2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar2UcharUcharUchar2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar3UcharUcharUchar3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x68ea3ae9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x1c6e882bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xadcb7a31l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar3UcharUcharUchar3(inValue, out);
            verifyResultsClampUchar3UcharUcharUchar3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3UcharUcharUchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar3UcharUcharUchar3(inValue, out);
            verifyResultsClampUchar3UcharUcharUchar3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3UcharUcharUchar3: " + e.toString());
        }
    }

    private void verifyResultsClampUchar3UcharUcharUchar3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar3UcharUcharUchar3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar4UcharUcharUchar4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0xe1a6686fl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x4f9cf01dl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xe0f9e223l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar4UcharUcharUchar4(inValue, out);
            verifyResultsClampUchar4UcharUcharUchar4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4UcharUcharUchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar4UcharUcharUchar4(inValue, out);
            verifyResultsClampUchar4UcharUcharUchar4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4UcharUcharUchar4: " + e.toString());
        }
    }

    private void verifyResultsClampUchar4UcharUcharUchar4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar4UcharUcharUchar4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort2ShortShortShort2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0xeae2d6a9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xcaca776bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x5c276971l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort2ShortShortShort2(inValue, out);
            verifyResultsClampShort2ShortShortShort2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2ShortShortShort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort2ShortShortShort2(inValue, out);
            verifyResultsClampShort2ShortShortShort2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2ShortShortShort2: " + e.toString());
        }
    }

    private void verifyResultsClampShort2ShortShortShort2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort2ShortShortShort2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort3ShortShortShort3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x639f042fl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xfdf8df5dl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x8f55d163l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort3ShortShortShort3(inValue, out);
            verifyResultsClampShort3ShortShortShort3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3ShortShortShort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort3ShortShortShort3(inValue, out);
            verifyResultsClampShort3ShortShortShort3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3ShortShortShort3: " + e.toString());
        }
    }

    private void verifyResultsClampShort3ShortShortShort3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort3ShortShortShort3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort4ShortShortShort4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xdc5b31b5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x3127474fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xc2843955l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort4ShortShortShort4(inValue, out);
            verifyResultsClampShort4ShortShortShort4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4ShortShortShort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort4ShortShortShort4(inValue, out);
            verifyResultsClampShort4ShortShortShort4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4ShortShortShort4: " + e.toString());
        }
    }

    private void verifyResultsClampShort4ShortShortShort4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort4ShortShortShort4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort2UshortUshortUshort2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x5621ef07l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xc7874965l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x58e43b6bl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort2UshortUshortUshort2(inValue, out);
            verifyResultsClampUshort2UshortUshortUshort2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2UshortUshortUshort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort2UshortUshortUshort2(inValue, out);
            verifyResultsClampUshort2UshortUshortUshort2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2UshortUshortUshort2: " + e.toString());
        }
    }

    private void verifyResultsClampUshort2UshortUshortUshort2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort2UshortUshortUshort2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort3UshortUshortUshort3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x7c9cd603l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xb3cf1419l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x452c061fl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort3UshortUshortUshort3(inValue, out);
            verifyResultsClampUshort3UshortUshortUshort3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3UshortUshortUshort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort3UshortUshortUshort3(inValue, out);
            verifyResultsClampUshort3UshortUshortUshort3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3UshortUshortUshort3: " + e.toString());
        }
    }

    private void verifyResultsClampUshort3UshortUshortUshort3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort3UshortUshortUshort3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort4UshortUshortUshort4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xa317bcffl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xa016decdl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x3173d0d3l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort4UshortUshortUshort4(inValue, out);
            verifyResultsClampUshort4UshortUshortUshort4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4UshortUshortUshort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort4UshortUshortUshort4(inValue, out);
            verifyResultsClampUshort4UshortUshortUshort4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4UshortUshortUshort4: " + e.toString());
        }
    }

    private void verifyResultsClampUshort4UshortUshortUshort4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort4UshortUshortUshort4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt2IntIntInt2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x7906d1dbl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xfba24121l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x8cff3327l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt2IntIntInt2(inValue, out);
            verifyResultsClampInt2IntIntInt2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2IntIntInt2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt2IntIntInt2(inValue, out);
            verifyResultsClampInt2IntIntInt2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2IntIntInt2: " + e.toString());
        }
    }

    private void verifyResultsClampInt2IntIntInt2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt2IntIntInt2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt3IntIntInt3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0xb5370be9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xf1a08b2bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x82fd7d31l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt3IntIntInt3(inValue, out);
            verifyResultsClampInt3IntIntInt3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3IntIntInt3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt3IntIntInt3(inValue, out);
            verifyResultsClampInt3IntIntInt3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3IntIntInt3: " + e.toString());
        }
    }

    private void verifyResultsClampInt3IntIntInt3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt3IntIntInt3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt4IntIntInt4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0xf16745f7l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xe79ed535l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x78fbc73bl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt4IntIntInt4(inValue, out);
            verifyResultsClampInt4IntIntInt4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4IntIntInt4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt4IntIntInt4(inValue, out);
            verifyResultsClampInt4IntIntInt4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4IntIntInt4: " + e.toString());
        }
    }

    private void verifyResultsClampInt4IntIntInt4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt4IntIntInt4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint2UintUintUint2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0x770d5a51l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xc2a180e3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x53fe72e9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint2UintUintUint2(inValue, out);
            verifyResultsClampUint2UintUintUint2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2UintUintUint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint2UintUintUint2(inValue, out);
            verifyResultsClampUint2UintUintUint2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2UintUintUint2: " + e.toString());
        }
    }

    private void verifyResultsClampUint2UintUintUint2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint2UintUintUint2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint3UintUintUint3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x60582365l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x48112f5fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xd96e2165l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint3UintUintUint3(inValue, out);
            verifyResultsClampUint3UintUintUint3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3UintUintUint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint3UintUintUint3(inValue, out);
            verifyResultsClampUint3UintUintUint3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3UintUintUint3: " + e.toString());
        }
    }

    private void verifyResultsClampUint3UintUintUint3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint3UintUintUint3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint4UintUintUint4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x49a2ec79l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xcd80dddbl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x5eddcfe1l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint4UintUintUint4(inValue, out);
            verifyResultsClampUint4UintUintUint4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4UintUintUint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint4UintUintUint4(inValue, out);
            verifyResultsClampUint4UintUintUint4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4UintUintUint4: " + e.toString());
        }
    }

    private void verifyResultsClampUint4UintUintUint4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint4UintUintUint4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong2LongLongLong2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0x7c535bb5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x8f83654fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x20e05755l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong2LongLongLong2(inValue, out);
            verifyResultsClampLong2LongLongLong2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong2LongLongLong2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong2LongLongLong2(inValue, out);
            verifyResultsClampLong2LongLongLong2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong2LongLongLong2: " + e.toString());
        }
    }

    private void verifyResultsClampLong2LongLongLong2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong2LongLongLong2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong3LongLongLong3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0x659e24c9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x14f313cbl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0xa65005d1l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong3LongLongLong3(inValue, out);
            verifyResultsClampLong3LongLongLong3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong3LongLongLong3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong3LongLongLong3(inValue, out);
            verifyResultsClampLong3LongLongLong3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong3LongLongLong3: " + e.toString());
        }
    }

    private void verifyResultsClampLong3LongLongLong3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong3LongLongLong3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong4LongLongLong4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0x4ee8edddl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x9a62c247l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x2bbfb44dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong4LongLongLong4(inValue, out);
            verifyResultsClampLong4LongLongLong4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong4LongLongLong4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong4LongLongLong4(inValue, out);
            verifyResultsClampLong4LongLongLong4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong4LongLongLong4: " + e.toString());
        }
    }

    private void verifyResultsClampLong4LongLongLong4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong4LongLongLong4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong2UlongUlongUlong2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0xa7fa1bf7l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x8d13b735l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x1e70a93bl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong2UlongUlongUlong2(inValue, out);
            verifyResultsClampUlong2UlongUlongUlong2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong2UlongUlongUlong2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong2UlongUlongUlong2(inValue, out);
            verifyResultsClampUlong2UlongUlongUlong2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong2UlongUlongUlong2: " + e.toString());
        }
    }

    private void verifyResultsClampUlong2UlongUlongUlong2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong2UlongUlongUlong2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong3UlongUlongUlong3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0x20b6497dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0xc0421f27l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x519f112dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong3UlongUlongUlong3(inValue, out);
            verifyResultsClampUlong3UlongUlongUlong3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong3UlongUlongUlong3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong3UlongUlongUlong3(inValue, out);
            verifyResultsClampUlong3UlongUlongUlong3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong3UlongUlongUlong3: " + e.toString());
        }
    }

    private void verifyResultsClampUlong3UlongUlongUlong3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong3UlongUlongUlong3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong4UlongUlongUlong4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x99727703l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0xf3708719l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x84cd791fl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong4UlongUlongUlong4(inValue, out);
            verifyResultsClampUlong4UlongUlongUlong4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong4UlongUlongUlong4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong4UlongUlongUlong4(inValue, out);
            verifyResultsClampUlong4UlongUlongUlong4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong4UlongUlongUlong4: " + e.toString());
        }
    }

    private void verifyResultsClampUlong4UlongUlongUlong4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong4UlongUlongUlong4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsHalfHalfHalfHalf {
        public short inValue;
        public double inValueDouble;
        public short inMinValue;
        public double inMinValueDouble;
        public short inMaxValue;
        public double inMaxValueDouble;
        public Target.Floaty out;
    }

    private void checkClampHalfHalfHalfHalf() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0x4b82831l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xf102f883l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0x825fea89l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalfHalfHalfHalf(inValue, out);
            verifyResultsClampHalfHalfHalfHalf(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalfHalfHalfHalf: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalfHalfHalfHalf(inValue, out);
            verifyResultsClampHalfHalfHalfHalf(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalfHalfHalfHalf: " + e.toString());
        }
    }

    private void verifyResultsClampHalfHalfHalfHalf(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 1 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 1 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 1 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalfHalfHalfHalf" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf2Half2Half2Half2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0xb1049715l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0x6f2ebd6fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0x8baf75l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf2Half2Half2Half2(inValue, out);
            verifyResultsClampHalf2Half2Half2Half2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf2Half2Half2Half2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf2Half2Half2Half2(inValue, out);
            verifyResultsClampHalf2Half2Half2Half2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf2Half2Half2Half2: " + e.toString());
        }
    }

    private void verifyResultsClampHalf2Half2Half2Half2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 2 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf2Half2Half2Half2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf3Half3Half3Half3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0xa6d9935dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0x81facac7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0x1357bccdl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf3Half3Half3Half3(inValue, out);
            verifyResultsClampHalf3Half3Half3Half3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf3Half3Half3Half3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf3Half3Half3Half3(inValue, out);
            verifyResultsClampHalf3Half3Half3Half3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf3Half3Half3Half3: " + e.toString());
        }
    }

    private void verifyResultsClampHalf3Half3Half3Half3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 4 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf3Half3Half3Half3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf4Half4Half4Half4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0x9cae8fa5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0x94c6d81fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0x2623ca25l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf4Half4Half4Half4(inValue, out);
            verifyResultsClampHalf4Half4Half4Half4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf4Half4Half4Half4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf4Half4Half4Half4(inValue, out);
            verifyResultsClampHalf4Half4Half4Half4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf4Half4Half4Half4: " + e.toString());
        }
    }

    private void verifyResultsClampHalf4Half4Half4Half4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 4 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf4Half4Half4Half4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf2HalfHalfHalf2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0x35f68507l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xbc3d6b65l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0x4d9a5d6bl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf2HalfHalfHalf2(inValue, out);
            verifyResultsClampHalf2HalfHalfHalf2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf2HalfHalfHalf2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf2HalfHalfHalf2(inValue, out);
            verifyResultsClampHalf2HalfHalfHalf2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf2HalfHalfHalf2: " + e.toString());
        }
    }

    private void verifyResultsClampHalf2HalfHalfHalf2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 2 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf2HalfHalfHalf2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf3HalfHalfHalf3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0x1f414e1bl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0x41ad19e1l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xd30a0be7l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf3HalfHalfHalf3(inValue, out);
            verifyResultsClampHalf3HalfHalfHalf3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf3HalfHalfHalf3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf3HalfHalfHalf3(inValue, out);
            verifyResultsClampHalf3HalfHalfHalf3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf3HalfHalfHalf3: " + e.toString());
        }
    }

    private void verifyResultsClampHalf3HalfHalfHalf3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 4 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf3HalfHalfHalf3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf4HalfHalfHalf4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0x88c172fl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xc71cc85dl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0x5879ba63l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf4HalfHalfHalf4(inValue, out);
            verifyResultsClampHalf4HalfHalfHalf4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf4HalfHalfHalf4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf4HalfHalfHalf4(inValue, out);
            verifyResultsClampHalf4HalfHalfHalf4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf4HalfHalfHalf4: " + e.toString());
        }
    }

    private void verifyResultsClampHalf4HalfHalfHalf4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 4 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf4HalfHalfHalf4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public void testClamp() {
        checkClampFloatFloatFloatFloat();
        checkClampFloat2Float2Float2Float2();
        checkClampFloat3Float3Float3Float3();
        checkClampFloat4Float4Float4Float4();
        checkClampFloat2FloatFloatFloat2();
        checkClampFloat3FloatFloatFloat3();
        checkClampFloat4FloatFloatFloat4();
        checkClampCharCharCharChar();
        checkClampChar2Char2Char2Char2();
        checkClampChar3Char3Char3Char3();
        checkClampChar4Char4Char4Char4();
        checkClampUcharUcharUcharUchar();
        checkClampUchar2Uchar2Uchar2Uchar2();
        checkClampUchar3Uchar3Uchar3Uchar3();
        checkClampUchar4Uchar4Uchar4Uchar4();
        checkClampShortShortShortShort();
        checkClampShort2Short2Short2Short2();
        checkClampShort3Short3Short3Short3();
        checkClampShort4Short4Short4Short4();
        checkClampUshortUshortUshortUshort();
        checkClampUshort2Ushort2Ushort2Ushort2();
        checkClampUshort3Ushort3Ushort3Ushort3();
        checkClampUshort4Ushort4Ushort4Ushort4();
        checkClampIntIntIntInt();
        checkClampInt2Int2Int2Int2();
        checkClampInt3Int3Int3Int3();
        checkClampInt4Int4Int4Int4();
        checkClampUintUintUintUint();
        checkClampUint2Uint2Uint2Uint2();
        checkClampUint3Uint3Uint3Uint3();
        checkClampUint4Uint4Uint4Uint4();
        checkClampLongLongLongLong();
        checkClampLong2Long2Long2Long2();
        checkClampLong3Long3Long3Long3();
        checkClampLong4Long4Long4Long4();
        checkClampUlongUlongUlongUlong();
        checkClampUlong2Ulong2Ulong2Ulong2();
        checkClampUlong3Ulong3Ulong3Ulong3();
        checkClampUlong4Ulong4Ulong4Ulong4();
        checkClampChar2CharCharChar2();
        checkClampChar3CharCharChar3();
        checkClampChar4CharCharChar4();
        checkClampUchar2UcharUcharUchar2();
        checkClampUchar3UcharUcharUchar3();
        checkClampUchar4UcharUcharUchar4();
        checkClampShort2ShortShortShort2();
        checkClampShort3ShortShortShort3();
        checkClampShort4ShortShortShort4();
        checkClampUshort2UshortUshortUshort2();
        checkClampUshort3UshortUshortUshort3();
        checkClampUshort4UshortUshortUshort4();
        checkClampInt2IntIntInt2();
        checkClampInt3IntIntInt3();
        checkClampInt4IntIntInt4();
        checkClampUint2UintUintUint2();
        checkClampUint3UintUintUint3();
        checkClampUint4UintUintUint4();
        checkClampLong2LongLongLong2();
        checkClampLong3LongLongLong3();
        checkClampLong4LongLongLong4();
        checkClampUlong2UlongUlongUlong2();
        checkClampUlong3UlongUlongUlong3();
        checkClampUlong4UlongUlongUlong4();
        checkClampHalfHalfHalfHalf();
        checkClampHalf2Half2Half2Half2();
        checkClampHalf3Half3Half3Half3();
        checkClampHalf4Half4Half4Half4();
        checkClampHalf2HalfHalfHalf2();
        checkClampHalf3HalfHalfHalf3();
        checkClampHalf4HalfHalfHalf4();
    }
}
