// Generated Code - DO NOT EDIT !!
// generated by 'emugen'
#include <stdio.h>
#include <stdlib.h>
#include "gl2_client_context.h"

#ifndef GL_TRUE
extern "C" {
	void glActiveTexture(GLenum texture);
	void glAttachShader(GLuint program, GLuint shader);
	void glBindAttribLocation(GLuint program, GLuint index, const GLchar* name);
	void glBindBuffer(GLenum target, GLuint buffer);
	void glBindFramebuffer(GLenum target, GLuint framebuffer);
	void glBindRenderbuffer(GLenum target, GLuint renderbuffer);
	void glBindTexture(GLenum target, GLuint texture);
	void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
	void glBlendEquation(GLenum mode);
	void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
	void glBlendFunc(GLenum sfactor, GLenum dfactor);
	void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
	void glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage);
	void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data);
	GLenum glCheckFramebufferStatus(GLenum target);
	void glClear(GLbitfield mask);
	void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
	void glClearDepthf(GLclampf depth);
	void glClearStencil(GLint s);
	void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
	void glCompileShader(GLuint shader);
	void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data);
	void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data);
	void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	GLuint glCreateProgram();
	GLuint glCreateShader(GLenum type);
	void glCullFace(GLenum mode);
	void glDeleteBuffers(GLsizei n, const GLuint* buffers);
	void glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers);
	void glDeleteProgram(GLuint program);
	void glDeleteRenderbuffers(GLsizei n, const GLuint* renderbuffers);
	void glDeleteShader(GLuint shader);
	void glDeleteTextures(GLsizei n, const GLuint* textures);
	void glDepthFunc(GLenum func);
	void glDepthMask(GLboolean flag);
	void glDepthRangef(GLclampf zNear, GLclampf zFar);
	void glDetachShader(GLuint program, GLuint shader);
	void glDisable(GLenum cap);
	void glDisableVertexAttribArray(GLuint index);
	void glDrawArrays(GLenum mode, GLint first, GLsizei count);
	void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices);
	void glEnable(GLenum cap);
	void glEnableVertexAttribArray(GLuint index);
	void glFinish();
	void glFlush();
	void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	void glFrontFace(GLenum mode);
	void glGenBuffers(GLsizei n, GLuint* buffers);
	void glGenerateMipmap(GLenum target);
	void glGenFramebuffers(GLsizei n, GLuint* framebuffers);
	void glGenRenderbuffers(GLsizei n, GLuint* renderbuffers);
	void glGenTextures(GLsizei n, GLuint* textures);
	void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
	void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
	void glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders);
	int glGetAttribLocation(GLuint program, const GLchar* name);
	void glGetBooleanv(GLenum pname, GLboolean* params);
	void glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params);
	GLenum glGetError();
	void glGetFloatv(GLenum pname, GLfloat* params);
	void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params);
	void glGetIntegerv(GLenum pname, GLint* params);
	void glGetProgramiv(GLuint program, GLenum pname, GLint* params);
	void glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog);
	void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params);
	void glGetShaderiv(GLuint shader, GLenum pname, GLint* params);
	void glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog);
	void glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
	void glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);
	const GLubyte* glGetString(GLenum name);
	void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params);
	void glGetTexParameteriv(GLenum target, GLenum pname, GLint* params);
	void glGetUniformfv(GLuint program, GLint location, GLfloat* params);
	void glGetUniformiv(GLuint program, GLint location, GLint* params);
	int glGetUniformLocation(GLuint program, const GLchar* name);
	void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params);
	void glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params);
	void glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer);
	void glHint(GLenum target, GLenum mode);
	GLboolean glIsBuffer(GLuint buffer);
	GLboolean glIsEnabled(GLenum cap);
	GLboolean glIsFramebuffer(GLuint framebuffer);
	GLboolean glIsProgram(GLuint program);
	GLboolean glIsRenderbuffer(GLuint renderbuffer);
	GLboolean glIsShader(GLuint shader);
	GLboolean glIsTexture(GLuint texture);
	void glLineWidth(GLfloat width);
	void glLinkProgram(GLuint program);
	void glPixelStorei(GLenum pname, GLint param);
	void glPolygonOffset(GLfloat factor, GLfloat units);
	void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);
	void glReleaseShaderCompiler();
	void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
	void glSampleCoverage(GLclampf value, GLboolean invert);
	void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
	void glShaderBinary(GLsizei n, const GLuint* shaders, GLenum binaryformat, const GLvoid* binary, GLsizei length);
	void glShaderSource(GLuint shader, GLsizei count, const GLchar* const* string, const GLint* length);
	void glStencilFunc(GLenum func, GLint ref, GLuint mask);
	void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
	void glStencilMask(GLuint mask);
	void glStencilMaskSeparate(GLenum face, GLuint mask);
	void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
	void glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
	void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels);
	void glTexParameterf(GLenum target, GLenum pname, GLfloat param);
	void glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params);
	void glTexParameteri(GLenum target, GLenum pname, GLint param);
	void glTexParameteriv(GLenum target, GLenum pname, const GLint* params);
	void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels);
	void glUniform1f(GLint location, GLfloat x);
	void glUniform1fv(GLint location, GLsizei count, const GLfloat* v);
	void glUniform1i(GLint location, GLint x);
	void glUniform1iv(GLint location, GLsizei count, const GLint* v);
	void glUniform2f(GLint location, GLfloat x, GLfloat y);
	void glUniform2fv(GLint location, GLsizei count, const GLfloat* v);
	void glUniform2i(GLint location, GLint x, GLint y);
	void glUniform2iv(GLint location, GLsizei count, const GLint* v);
	void glUniform3f(GLint location, GLfloat x, GLfloat y, GLfloat z);
	void glUniform3fv(GLint location, GLsizei count, const GLfloat* v);
	void glUniform3i(GLint location, GLint x, GLint y, GLint z);
	void glUniform3iv(GLint location, GLsizei count, const GLint* v);
	void glUniform4f(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	void glUniform4fv(GLint location, GLsizei count, const GLfloat* v);
	void glUniform4i(GLint location, GLint x, GLint y, GLint z, GLint w);
	void glUniform4iv(GLint location, GLsizei count, const GLint* v);
	void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void glUseProgram(GLuint program);
	void glValidateProgram(GLuint program);
	void glVertexAttrib1f(GLuint indx, GLfloat x);
	void glVertexAttrib1fv(GLuint indx, const GLfloat* values);
	void glVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);
	void glVertexAttrib2fv(GLuint indx, const GLfloat* values);
	void glVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);
	void glVertexAttrib3fv(GLuint indx, const GLfloat* values);
	void glVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	void glVertexAttrib4fv(GLuint indx, const GLfloat* values);
	void glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr);
	void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
	void glEGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image);
	void glEGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image);
	void glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, GLvoid* binary);
	void glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid* binary, GLint length);
	void* glMapBufferOES(GLenum target, GLenum access);
	GLboolean glUnmapBufferOES(GLenum target);
	void glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* pixels);
	void glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* pixels);
	void glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	void glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data);
	void glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data);
	void glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
	void glBindVertexArrayOES(GLuint array);
	void glDeleteVertexArraysOES(GLsizei n, const GLuint* arrays);
	void glGenVertexArraysOES(GLsizei n, GLuint* arrays);
	GLboolean glIsVertexArrayOES(GLuint array);
	void glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum* attachments);
	void glMultiDrawArraysEXT(GLenum mode, const GLint* first, const GLsizei* count, GLsizei primcount);
	void glMultiDrawElementsEXT(GLenum mode, const GLsizei* count, GLenum type, const GLvoid* const* indices, GLsizei primcount);
	void glGetPerfMonitorGroupsAMD(GLint* numGroups, GLsizei groupsSize, GLuint* groups);
	void glGetPerfMonitorCountersAMD(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters);
	void glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString);
	void glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString);
	void glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid* data);
	void glGenPerfMonitorsAMD(GLsizei n, GLuint* monitors);
	void glDeletePerfMonitorsAMD(GLsizei n, GLuint* monitors);
	void glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* countersList);
	void glBeginPerfMonitorAMD(GLuint monitor);
	void glEndPerfMonitorAMD(GLuint monitor);
	void glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten);
	void glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	void glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);
	void glDeleteFencesNV(GLsizei n, const GLuint* fences);
	void glGenFencesNV(GLsizei n, GLuint* fences);
	GLboolean glIsFenceNV(GLuint fence);
	GLboolean glTestFenceNV(GLuint fence);
	void glGetFenceivNV(GLuint fence, GLenum pname, GLint* params);
	void glFinishFenceNV(GLuint fence);
	void glSetFenceNV(GLuint fence, GLenum condition);
	void glCoverageMaskNV(GLboolean mask);
	void glCoverageOperationNV(GLenum operation);
	void glGetDriverControlsQCOM(GLint* num, GLsizei size, GLuint* driverControls);
	void glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar* driverControlString);
	void glEnableDriverControlQCOM(GLuint driverControl);
	void glDisableDriverControlQCOM(GLuint driverControl);
	void glExtGetTexturesQCOM(GLuint* textures, GLint maxTextures, GLint* numTextures);
	void glExtGetBuffersQCOM(GLuint* buffers, GLint maxBuffers, GLint* numBuffers);
	void glExtGetRenderbuffersQCOM(GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers);
	void glExtGetFramebuffersQCOM(GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers);
	void glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params);
	void glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param);
	void glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid* texels);
	void glExtGetBufferPointervQCOM(GLenum target, GLvoidptr* params);
	void glExtGetShadersQCOM(GLuint* shaders, GLint maxShaders, GLint* numShaders);
	void glExtGetProgramsQCOM(GLuint* programs, GLint maxPrograms, GLint* numPrograms);
	GLboolean glExtIsProgramBinaryQCOM(GLuint program);
	void glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar* source, GLint* length);
	void glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);
	void glEndTilingQCOM(GLbitfield preserveMask);
	void glVertexAttribPointerData(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, void* data, GLuint datalen);
	void glVertexAttribPointerOffset(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint offset);
	void glDrawElementsOffset(GLenum mode, GLsizei count, GLenum type, GLuint offset);
	void glDrawElementsData(GLenum mode, GLsizei count, GLenum type, void* data, GLuint datalen);
	void glGetCompressedTextureFormats(int count, GLint* formats);
	void glShaderString(GLuint shader, const GLchar* string, GLsizei len);
	int glFinishRoundTrip();
};

#endif
#ifndef GET_CONTEXT
static gl2_client_context_t::CONTEXT_ACCESSOR_TYPE *getCurrentContext = NULL;
void gl2_client_context_t::setContextAccessor(CONTEXT_ACCESSOR_TYPE *f) { getCurrentContext = f; }
#define GET_CONTEXT gl2_client_context_t * ctx = getCurrentContext()
#endif

void glActiveTexture(GLenum texture)
{
	GET_CONTEXT;
	ctx->glActiveTexture(ctx, texture);
}

void glAttachShader(GLuint program, GLuint shader)
{
	GET_CONTEXT;
	ctx->glAttachShader(ctx, program, shader);
}

void glBindAttribLocation(GLuint program, GLuint index, const GLchar* name)
{
	GET_CONTEXT;
	ctx->glBindAttribLocation(ctx, program, index, name);
}

void glBindBuffer(GLenum target, GLuint buffer)
{
	GET_CONTEXT;
	ctx->glBindBuffer(ctx, target, buffer);
}

void glBindFramebuffer(GLenum target, GLuint framebuffer)
{
	GET_CONTEXT;
	ctx->glBindFramebuffer(ctx, target, framebuffer);
}

void glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
	GET_CONTEXT;
	ctx->glBindRenderbuffer(ctx, target, renderbuffer);
}

void glBindTexture(GLenum target, GLuint texture)
{
	GET_CONTEXT;
	ctx->glBindTexture(ctx, target, texture);
}

void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	GET_CONTEXT;
	ctx->glBlendColor(ctx, red, green, blue, alpha);
}

void glBlendEquation(GLenum mode)
{
	GET_CONTEXT;
	ctx->glBlendEquation(ctx, mode);
}

void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
	GET_CONTEXT;
	ctx->glBlendEquationSeparate(ctx, modeRGB, modeAlpha);
}

void glBlendFunc(GLenum sfactor, GLenum dfactor)
{
	GET_CONTEXT;
	ctx->glBlendFunc(ctx, sfactor, dfactor);
}

void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
	GET_CONTEXT;
	ctx->glBlendFuncSeparate(ctx, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

void glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage)
{
	GET_CONTEXT;
	ctx->glBufferData(ctx, target, size, data, usage);
}

void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data)
{
	GET_CONTEXT;
	ctx->glBufferSubData(ctx, target, offset, size, data);
}

GLenum glCheckFramebufferStatus(GLenum target)
{
	GET_CONTEXT;
	return ctx->glCheckFramebufferStatus(ctx, target);
}

void glClear(GLbitfield mask)
{
	GET_CONTEXT;
	ctx->glClear(ctx, mask);
}

void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	GET_CONTEXT;
	ctx->glClearColor(ctx, red, green, blue, alpha);
}

void glClearDepthf(GLclampf depth)
{
	GET_CONTEXT;
	ctx->glClearDepthf(ctx, depth);
}

void glClearStencil(GLint s)
{
	GET_CONTEXT;
	ctx->glClearStencil(ctx, s);
}

void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
	GET_CONTEXT;
	ctx->glColorMask(ctx, red, green, blue, alpha);
}

void glCompileShader(GLuint shader)
{
	GET_CONTEXT;
	ctx->glCompileShader(ctx, shader);
}

void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data)
{
	GET_CONTEXT;
	ctx->glCompressedTexImage2D(ctx, target, level, internalformat, width, height, border, imageSize, data);
}

void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data)
{
	GET_CONTEXT;
	ctx->glCompressedTexSubImage2D(ctx, target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
	GET_CONTEXT;
	ctx->glCopyTexImage2D(ctx, target, level, internalformat, x, y, width, height, border);
}

void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	GET_CONTEXT;
	ctx->glCopyTexSubImage2D(ctx, target, level, xoffset, yoffset, x, y, width, height);
}

GLuint glCreateProgram()
{
	GET_CONTEXT;
	return ctx->glCreateProgram(ctx);
}

GLuint glCreateShader(GLenum type)
{
	GET_CONTEXT;
	return ctx->glCreateShader(ctx, type);
}

void glCullFace(GLenum mode)
{
	GET_CONTEXT;
	ctx->glCullFace(ctx, mode);
}

void glDeleteBuffers(GLsizei n, const GLuint* buffers)
{
	GET_CONTEXT;
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	ctx->glDeleteBuffers(ctx, n, buffers);
}

void glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers)
{
	GET_CONTEXT;
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	ctx->glDeleteFramebuffers(ctx, n, framebuffers);
}

void glDeleteProgram(GLuint program)
{
	GET_CONTEXT;
	ctx->glDeleteProgram(ctx, program);
}

void glDeleteRenderbuffers(GLsizei n, const GLuint* renderbuffers)
{
	GET_CONTEXT;
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	ctx->glDeleteRenderbuffers(ctx, n, renderbuffers);
}

void glDeleteShader(GLuint shader)
{
	GET_CONTEXT;
	ctx->glDeleteShader(ctx, shader);
}

void glDeleteTextures(GLsizei n, const GLuint* textures)
{
	GET_CONTEXT;
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	ctx->glDeleteTextures(ctx, n, textures);
}

void glDepthFunc(GLenum func)
{
	GET_CONTEXT;
	ctx->glDepthFunc(ctx, func);
}

void glDepthMask(GLboolean flag)
{
	GET_CONTEXT;
	ctx->glDepthMask(ctx, flag);
}

void glDepthRangef(GLclampf zNear, GLclampf zFar)
{
	GET_CONTEXT;
	ctx->glDepthRangef(ctx, zNear, zFar);
}

void glDetachShader(GLuint program, GLuint shader)
{
	GET_CONTEXT;
	ctx->glDetachShader(ctx, program, shader);
}

void glDisable(GLenum cap)
{
	GET_CONTEXT;
	ctx->glDisable(ctx, cap);
}

void glDisableVertexAttribArray(GLuint index)
{
	GET_CONTEXT;
	ctx->glDisableVertexAttribArray(ctx, index);
}

void glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
	GET_CONTEXT;
	ctx->glDrawArrays(ctx, mode, first, count);
}

void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices)
{
	GET_CONTEXT;
	ctx->glDrawElements(ctx, mode, count, type, indices);
}

void glEnable(GLenum cap)
{
	GET_CONTEXT;
	ctx->glEnable(ctx, cap);
}

void glEnableVertexAttribArray(GLuint index)
{
	GET_CONTEXT;
	ctx->glEnableVertexAttribArray(ctx, index);
}

void glFinish()
{
	GET_CONTEXT;
	ctx->glFinish(ctx);
}

void glFlush()
{
	GET_CONTEXT;
	ctx->glFlush(ctx);
}

void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
	GET_CONTEXT;
	ctx->glFramebufferRenderbuffer(ctx, target, attachment, renderbuffertarget, renderbuffer);
}

void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	GET_CONTEXT;
	ctx->glFramebufferTexture2D(ctx, target, attachment, textarget, texture, level);
}

void glFrontFace(GLenum mode)
{
	GET_CONTEXT;
	ctx->glFrontFace(ctx, mode);
}

void glGenBuffers(GLsizei n, GLuint* buffers)
{
	GET_CONTEXT;
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	ctx->glGenBuffers(ctx, n, buffers);
}

void glGenerateMipmap(GLenum target)
{
	GET_CONTEXT;
	ctx->glGenerateMipmap(ctx, target);
}

void glGenFramebuffers(GLsizei n, GLuint* framebuffers)
{
	GET_CONTEXT;
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	ctx->glGenFramebuffers(ctx, n, framebuffers);
}

void glGenRenderbuffers(GLsizei n, GLuint* renderbuffers)
{
	GET_CONTEXT;
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	ctx->glGenRenderbuffers(ctx, n, renderbuffers);
}

void glGenTextures(GLsizei n, GLuint* textures)
{
	GET_CONTEXT;
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	ctx->glGenTextures(ctx, n, textures);
}

void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{
	GET_CONTEXT;
	ctx->glGetActiveAttrib(ctx, program, index, bufsize, length, size, type, name);
}

void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{
	GET_CONTEXT;
	ctx->glGetActiveUniform(ctx, program, index, bufsize, length, size, type, name);
}

void glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders)
{
	GET_CONTEXT;
	ctx->glGetAttachedShaders(ctx, program, maxcount, count, shaders);
}

int glGetAttribLocation(GLuint program, const GLchar* name)
{
	GET_CONTEXT;
	return ctx->glGetAttribLocation(ctx, program, name);
}

void glGetBooleanv(GLenum pname, GLboolean* params)
{
	GET_CONTEXT;
	ctx->glGetBooleanv(ctx, pname, params);
}

void glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params)
{
	GET_CONTEXT;
	ctx->glGetBufferParameteriv(ctx, target, pname, params);
}

GLenum glGetError()
{
	GET_CONTEXT;
	return ctx->glGetError(ctx);
}

void glGetFloatv(GLenum pname, GLfloat* params)
{
	GET_CONTEXT;
	ctx->glGetFloatv(ctx, pname, params);
}

void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params)
{
	GET_CONTEXT;
	ctx->glGetFramebufferAttachmentParameteriv(ctx, target, attachment, pname, params);
}

void glGetIntegerv(GLenum pname, GLint* params)
{
	GET_CONTEXT;
	ctx->glGetIntegerv(ctx, pname, params);
}

void glGetProgramiv(GLuint program, GLenum pname, GLint* params)
{
	GET_CONTEXT;
	ctx->glGetProgramiv(ctx, program, pname, params);
}

void glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog)
{
	GET_CONTEXT;
	ctx->glGetProgramInfoLog(ctx, program, bufsize, length, infolog);
}

void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params)
{
	GET_CONTEXT;
	ctx->glGetRenderbufferParameteriv(ctx, target, pname, params);
}

void glGetShaderiv(GLuint shader, GLenum pname, GLint* params)
{
	GET_CONTEXT;
	ctx->glGetShaderiv(ctx, shader, pname, params);
}

void glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog)
{
	GET_CONTEXT;
	ctx->glGetShaderInfoLog(ctx, shader, bufsize, length, infolog);
}

void glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision)
{
	GET_CONTEXT;
	ctx->glGetShaderPrecisionFormat(ctx, shadertype, precisiontype, range, precision);
}

void glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source)
{
	GET_CONTEXT;
	ctx->glGetShaderSource(ctx, shader, bufsize, length, source);
}

const GLubyte* glGetString(GLenum name)
{
	GET_CONTEXT;
	return ctx->glGetString(ctx, name);
}

void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params)
{
	GET_CONTEXT;
	ctx->glGetTexParameterfv(ctx, target, pname, params);
}

void glGetTexParameteriv(GLenum target, GLenum pname, GLint* params)
{
	GET_CONTEXT;
	ctx->glGetTexParameteriv(ctx, target, pname, params);
}

void glGetUniformfv(GLuint program, GLint location, GLfloat* params)
{
	GET_CONTEXT;
	ctx->glGetUniformfv(ctx, program, location, params);
}

void glGetUniformiv(GLuint program, GLint location, GLint* params)
{
	GET_CONTEXT;
	ctx->glGetUniformiv(ctx, program, location, params);
}

int glGetUniformLocation(GLuint program, const GLchar* name)
{
	GET_CONTEXT;
	return ctx->glGetUniformLocation(ctx, program, name);
}

void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params)
{
	GET_CONTEXT;
	ctx->glGetVertexAttribfv(ctx, index, pname, params);
}

void glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params)
{
	GET_CONTEXT;
	ctx->glGetVertexAttribiv(ctx, index, pname, params);
}

void glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer)
{
	GET_CONTEXT;
	ctx->glGetVertexAttribPointerv(ctx, index, pname, pointer);
}

void glHint(GLenum target, GLenum mode)
{
	GET_CONTEXT;
	ctx->glHint(ctx, target, mode);
}

GLboolean glIsBuffer(GLuint buffer)
{
	GET_CONTEXT;
	return ctx->glIsBuffer(ctx, buffer);
}

GLboolean glIsEnabled(GLenum cap)
{
	GET_CONTEXT;
	return ctx->glIsEnabled(ctx, cap);
}

GLboolean glIsFramebuffer(GLuint framebuffer)
{
	GET_CONTEXT;
	return ctx->glIsFramebuffer(ctx, framebuffer);
}

GLboolean glIsProgram(GLuint program)
{
	GET_CONTEXT;
	return ctx->glIsProgram(ctx, program);
}

GLboolean glIsRenderbuffer(GLuint renderbuffer)
{
	GET_CONTEXT;
	return ctx->glIsRenderbuffer(ctx, renderbuffer);
}

GLboolean glIsShader(GLuint shader)
{
	GET_CONTEXT;
	return ctx->glIsShader(ctx, shader);
}

GLboolean glIsTexture(GLuint texture)
{
	GET_CONTEXT;
	return ctx->glIsTexture(ctx, texture);
}

void glLineWidth(GLfloat width)
{
	GET_CONTEXT;
	ctx->glLineWidth(ctx, width);
}

void glLinkProgram(GLuint program)
{
	GET_CONTEXT;
	ctx->glLinkProgram(ctx, program);
}

void glPixelStorei(GLenum pname, GLint param)
{
	GET_CONTEXT;
	ctx->glPixelStorei(ctx, pname, param);
}

void glPolygonOffset(GLfloat factor, GLfloat units)
{
	GET_CONTEXT;
	ctx->glPolygonOffset(ctx, factor, units);
}

void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
{
	GET_CONTEXT;
	ctx->glReadPixels(ctx, x, y, width, height, format, type, pixels);
}

void glReleaseShaderCompiler()
{
	GET_CONTEXT;
	ctx->glReleaseShaderCompiler(ctx);
}

void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
	GET_CONTEXT;
	ctx->glRenderbufferStorage(ctx, target, internalformat, width, height);
}

void glSampleCoverage(GLclampf value, GLboolean invert)
{
	GET_CONTEXT;
	ctx->glSampleCoverage(ctx, value, invert);
}

void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
	GET_CONTEXT;
	ctx->glScissor(ctx, x, y, width, height);
}

void glShaderBinary(GLsizei n, const GLuint* shaders, GLenum binaryformat, const GLvoid* binary, GLsizei length)
{
	GET_CONTEXT;
	ctx->glShaderBinary(ctx, n, shaders, binaryformat, binary, length);
}

void glShaderSource(GLuint shader, GLsizei count, const GLchar* const* string, const GLint* length)
{
	GET_CONTEXT;
	ctx->glShaderSource(ctx, shader, count, string, length);
}

void glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
	GET_CONTEXT;
	ctx->glStencilFunc(ctx, func, ref, mask);
}

void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
	GET_CONTEXT;
	ctx->glStencilFuncSeparate(ctx, face, func, ref, mask);
}

void glStencilMask(GLuint mask)
{
	GET_CONTEXT;
	ctx->glStencilMask(ctx, mask);
}

void glStencilMaskSeparate(GLenum face, GLuint mask)
{
	GET_CONTEXT;
	ctx->glStencilMaskSeparate(ctx, face, mask);
}

void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
	GET_CONTEXT;
	ctx->glStencilOp(ctx, fail, zfail, zpass);
}

void glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
	GET_CONTEXT;
	ctx->glStencilOpSeparate(ctx, face, fail, zfail, zpass);
}

void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels)
{
	GET_CONTEXT;
	ctx->glTexImage2D(ctx, target, level, internalformat, width, height, border, format, type, pixels);
}

void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
	GET_CONTEXT;
	ctx->glTexParameterf(ctx, target, pname, param);
}

void glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params)
{
	GET_CONTEXT;
	ctx->glTexParameterfv(ctx, target, pname, params);
}

void glTexParameteri(GLenum target, GLenum pname, GLint param)
{
	GET_CONTEXT;
	ctx->glTexParameteri(ctx, target, pname, param);
}

void glTexParameteriv(GLenum target, GLenum pname, const GLint* params)
{
	GET_CONTEXT;
	ctx->glTexParameteriv(ctx, target, pname, params);
}

void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels)
{
	GET_CONTEXT;
	ctx->glTexSubImage2D(ctx, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

void glUniform1f(GLint location, GLfloat x)
{
	GET_CONTEXT;
	ctx->glUniform1f(ctx, location, x);
}

void glUniform1fv(GLint location, GLsizei count, const GLfloat* v)
{
	GET_CONTEXT;
	ctx->glUniform1fv(ctx, location, count, v);
}

void glUniform1i(GLint location, GLint x)
{
	GET_CONTEXT;
	ctx->glUniform1i(ctx, location, x);
}

void glUniform1iv(GLint location, GLsizei count, const GLint* v)
{
	GET_CONTEXT;
	ctx->glUniform1iv(ctx, location, count, v);
}

void glUniform2f(GLint location, GLfloat x, GLfloat y)
{
	GET_CONTEXT;
	ctx->glUniform2f(ctx, location, x, y);
}

void glUniform2fv(GLint location, GLsizei count, const GLfloat* v)
{
	GET_CONTEXT;
	ctx->glUniform2fv(ctx, location, count, v);
}

void glUniform2i(GLint location, GLint x, GLint y)
{
	GET_CONTEXT;
	ctx->glUniform2i(ctx, location, x, y);
}

void glUniform2iv(GLint location, GLsizei count, const GLint* v)
{
	GET_CONTEXT;
	ctx->glUniform2iv(ctx, location, count, v);
}

void glUniform3f(GLint location, GLfloat x, GLfloat y, GLfloat z)
{
	GET_CONTEXT;
	ctx->glUniform3f(ctx, location, x, y, z);
}

void glUniform3fv(GLint location, GLsizei count, const GLfloat* v)
{
	GET_CONTEXT;
	ctx->glUniform3fv(ctx, location, count, v);
}

void glUniform3i(GLint location, GLint x, GLint y, GLint z)
{
	GET_CONTEXT;
	ctx->glUniform3i(ctx, location, x, y, z);
}

void glUniform3iv(GLint location, GLsizei count, const GLint* v)
{
	GET_CONTEXT;
	ctx->glUniform3iv(ctx, location, count, v);
}

void glUniform4f(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	GET_CONTEXT;
	ctx->glUniform4f(ctx, location, x, y, z, w);
}

void glUniform4fv(GLint location, GLsizei count, const GLfloat* v)
{
	GET_CONTEXT;
	ctx->glUniform4fv(ctx, location, count, v);
}

void glUniform4i(GLint location, GLint x, GLint y, GLint z, GLint w)
{
	GET_CONTEXT;
	ctx->glUniform4i(ctx, location, x, y, z, w);
}

void glUniform4iv(GLint location, GLsizei count, const GLint* v)
{
	GET_CONTEXT;
	ctx->glUniform4iv(ctx, location, count, v);
}

void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT;
	ctx->glUniformMatrix2fv(ctx, location, count, transpose, value);
}

void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT;
	ctx->glUniformMatrix3fv(ctx, location, count, transpose, value);
}

void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT;
	ctx->glUniformMatrix4fv(ctx, location, count, transpose, value);
}

void glUseProgram(GLuint program)
{
	GET_CONTEXT;
	ctx->glUseProgram(ctx, program);
}

void glValidateProgram(GLuint program)
{
	GET_CONTEXT;
	ctx->glValidateProgram(ctx, program);
}

void glVertexAttrib1f(GLuint indx, GLfloat x)
{
	GET_CONTEXT;
	ctx->glVertexAttrib1f(ctx, indx, x);
}

void glVertexAttrib1fv(GLuint indx, const GLfloat* values)
{
	GET_CONTEXT;
	ctx->glVertexAttrib1fv(ctx, indx, values);
}

void glVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y)
{
	GET_CONTEXT;
	ctx->glVertexAttrib2f(ctx, indx, x, y);
}

void glVertexAttrib2fv(GLuint indx, const GLfloat* values)
{
	GET_CONTEXT;
	ctx->glVertexAttrib2fv(ctx, indx, values);
}

void glVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z)
{
	GET_CONTEXT;
	ctx->glVertexAttrib3f(ctx, indx, x, y, z);
}

void glVertexAttrib3fv(GLuint indx, const GLfloat* values)
{
	GET_CONTEXT;
	ctx->glVertexAttrib3fv(ctx, indx, values);
}

void glVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	GET_CONTEXT;
	ctx->glVertexAttrib4f(ctx, indx, x, y, z, w);
}

void glVertexAttrib4fv(GLuint indx, const GLfloat* values)
{
	GET_CONTEXT;
	ctx->glVertexAttrib4fv(ctx, indx, values);
}

void glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr)
{
	GET_CONTEXT;
	ctx->glVertexAttribPointer(ctx, indx, size, type, normalized, stride, ptr);
}

void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
	GET_CONTEXT;
	ctx->glViewport(ctx, x, y, width, height);
}

void glEGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image)
{
	GET_CONTEXT;
	ctx->glEGLImageTargetTexture2DOES(ctx, target, image);
}

void glEGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image)
{
	GET_CONTEXT;
	ctx->glEGLImageTargetRenderbufferStorageOES(ctx, target, image);
}

void glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, GLvoid* binary)
{
	GET_CONTEXT;
	ctx->glGetProgramBinaryOES(ctx, program, bufSize, length, binaryFormat, binary);
}

void glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid* binary, GLint length)
{
	GET_CONTEXT;
	ctx->glProgramBinaryOES(ctx, program, binaryFormat, binary, length);
}

void* glMapBufferOES(GLenum target, GLenum access)
{
	GET_CONTEXT;
	return ctx->glMapBufferOES(ctx, target, access);
}

GLboolean glUnmapBufferOES(GLenum target)
{
	GET_CONTEXT;
	return ctx->glUnmapBufferOES(ctx, target);
}

void glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* pixels)
{
	GET_CONTEXT;
	ctx->glTexImage3DOES(ctx, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

void glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* pixels)
{
	GET_CONTEXT;
	ctx->glTexSubImage3DOES(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

void glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	GET_CONTEXT;
	ctx->glCopyTexSubImage3DOES(ctx, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

void glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data)
{
	GET_CONTEXT;
	ctx->glCompressedTexImage3DOES(ctx, target, level, internalformat, width, height, depth, border, imageSize, data);
}

void glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data)
{
	GET_CONTEXT;
	ctx->glCompressedTexSubImage3DOES(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

void glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
	GET_CONTEXT;
	ctx->glFramebufferTexture3DOES(ctx, target, attachment, textarget, texture, level, zoffset);
}

void glBindVertexArrayOES(GLuint array)
{
	GET_CONTEXT;
	ctx->glBindVertexArrayOES(ctx, array);
}

void glDeleteVertexArraysOES(GLsizei n, const GLuint* arrays)
{
	GET_CONTEXT;
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	ctx->glDeleteVertexArraysOES(ctx, n, arrays);
}

void glGenVertexArraysOES(GLsizei n, GLuint* arrays)
{
	GET_CONTEXT;
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	ctx->glGenVertexArraysOES(ctx, n, arrays);
}

GLboolean glIsVertexArrayOES(GLuint array)
{
	GET_CONTEXT;
	return ctx->glIsVertexArrayOES(ctx, array);
}

void glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum* attachments)
{
	GET_CONTEXT;
	ctx->glDiscardFramebufferEXT(ctx, target, numAttachments, attachments);
}

void glMultiDrawArraysEXT(GLenum mode, const GLint* first, const GLsizei* count, GLsizei primcount)
{
	GET_CONTEXT;
	ctx->glMultiDrawArraysEXT(ctx, mode, first, count, primcount);
}

void glMultiDrawElementsEXT(GLenum mode, const GLsizei* count, GLenum type, const GLvoid* const* indices, GLsizei primcount)
{
	GET_CONTEXT;
	ctx->glMultiDrawElementsEXT(ctx, mode, count, type, indices, primcount);
}

void glGetPerfMonitorGroupsAMD(GLint* numGroups, GLsizei groupsSize, GLuint* groups)
{
	GET_CONTEXT;
	ctx->glGetPerfMonitorGroupsAMD(ctx, numGroups, groupsSize, groups);
}

void glGetPerfMonitorCountersAMD(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters)
{
	GET_CONTEXT;
	ctx->glGetPerfMonitorCountersAMD(ctx, group, numCounters, maxActiveCounters, counterSize, counters);
}

void glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString)
{
	GET_CONTEXT;
	ctx->glGetPerfMonitorGroupStringAMD(ctx, group, bufSize, length, groupString);
}

void glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString)
{
	GET_CONTEXT;
	ctx->glGetPerfMonitorCounterStringAMD(ctx, group, counter, bufSize, length, counterString);
}

void glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid* data)
{
	GET_CONTEXT;
	ctx->glGetPerfMonitorCounterInfoAMD(ctx, group, counter, pname, data);
}

void glGenPerfMonitorsAMD(GLsizei n, GLuint* monitors)
{
	GET_CONTEXT;
	ctx->glGenPerfMonitorsAMD(ctx, n, monitors);
}

void glDeletePerfMonitorsAMD(GLsizei n, GLuint* monitors)
{
	GET_CONTEXT;
	ctx->glDeletePerfMonitorsAMD(ctx, n, monitors);
}

void glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* countersList)
{
	GET_CONTEXT;
	ctx->glSelectPerfMonitorCountersAMD(ctx, monitor, enable, group, numCounters, countersList);
}

void glBeginPerfMonitorAMD(GLuint monitor)
{
	GET_CONTEXT;
	ctx->glBeginPerfMonitorAMD(ctx, monitor);
}

void glEndPerfMonitorAMD(GLuint monitor)
{
	GET_CONTEXT;
	ctx->glEndPerfMonitorAMD(ctx, monitor);
}

void glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten)
{
	GET_CONTEXT;
	ctx->glGetPerfMonitorCounterDataAMD(ctx, monitor, pname, dataSize, data, bytesWritten);
}

void glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
	GET_CONTEXT;
	ctx->glRenderbufferStorageMultisampleIMG(ctx, target, samples, internalformat, width, height);
}

void glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
	GET_CONTEXT;
	ctx->glFramebufferTexture2DMultisampleIMG(ctx, target, attachment, textarget, texture, level, samples);
}

void glDeleteFencesNV(GLsizei n, const GLuint* fences)
{
	GET_CONTEXT;
	ctx->glDeleteFencesNV(ctx, n, fences);
}

void glGenFencesNV(GLsizei n, GLuint* fences)
{
	GET_CONTEXT;
	ctx->glGenFencesNV(ctx, n, fences);
}

GLboolean glIsFenceNV(GLuint fence)
{
	GET_CONTEXT;
	return ctx->glIsFenceNV(ctx, fence);
}

GLboolean glTestFenceNV(GLuint fence)
{
	GET_CONTEXT;
	return ctx->glTestFenceNV(ctx, fence);
}

void glGetFenceivNV(GLuint fence, GLenum pname, GLint* params)
{
	GET_CONTEXT;
	ctx->glGetFenceivNV(ctx, fence, pname, params);
}

void glFinishFenceNV(GLuint fence)
{
	GET_CONTEXT;
	ctx->glFinishFenceNV(ctx, fence);
}

void glSetFenceNV(GLuint fence, GLenum condition)
{
	GET_CONTEXT;
	ctx->glSetFenceNV(ctx, fence, condition);
}

void glCoverageMaskNV(GLboolean mask)
{
	GET_CONTEXT;
	ctx->glCoverageMaskNV(ctx, mask);
}

void glCoverageOperationNV(GLenum operation)
{
	GET_CONTEXT;
	ctx->glCoverageOperationNV(ctx, operation);
}

void glGetDriverControlsQCOM(GLint* num, GLsizei size, GLuint* driverControls)
{
	GET_CONTEXT;
	ctx->glGetDriverControlsQCOM(ctx, num, size, driverControls);
}

void glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar* driverControlString)
{
	GET_CONTEXT;
	ctx->glGetDriverControlStringQCOM(ctx, driverControl, bufSize, length, driverControlString);
}

void glEnableDriverControlQCOM(GLuint driverControl)
{
	GET_CONTEXT;
	ctx->glEnableDriverControlQCOM(ctx, driverControl);
}

void glDisableDriverControlQCOM(GLuint driverControl)
{
	GET_CONTEXT;
	ctx->glDisableDriverControlQCOM(ctx, driverControl);
}

void glExtGetTexturesQCOM(GLuint* textures, GLint maxTextures, GLint* numTextures)
{
	GET_CONTEXT;
	ctx->glExtGetTexturesQCOM(ctx, textures, maxTextures, numTextures);
}

void glExtGetBuffersQCOM(GLuint* buffers, GLint maxBuffers, GLint* numBuffers)
{
	GET_CONTEXT;
	ctx->glExtGetBuffersQCOM(ctx, buffers, maxBuffers, numBuffers);
}

void glExtGetRenderbuffersQCOM(GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers)
{
	GET_CONTEXT;
	ctx->glExtGetRenderbuffersQCOM(ctx, renderbuffers, maxRenderbuffers, numRenderbuffers);
}

void glExtGetFramebuffersQCOM(GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers)
{
	GET_CONTEXT;
	ctx->glExtGetFramebuffersQCOM(ctx, framebuffers, maxFramebuffers, numFramebuffers);
}

void glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params)
{
	GET_CONTEXT;
	ctx->glExtGetTexLevelParameterivQCOM(ctx, texture, face, level, pname, params);
}

void glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param)
{
	GET_CONTEXT;
	ctx->glExtTexObjectStateOverrideiQCOM(ctx, target, pname, param);
}

void glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid* texels)
{
	GET_CONTEXT;
	ctx->glExtGetTexSubImageQCOM(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
}

void glExtGetBufferPointervQCOM(GLenum target, GLvoidptr* params)
{
	GET_CONTEXT;
	ctx->glExtGetBufferPointervQCOM(ctx, target, params);
}

void glExtGetShadersQCOM(GLuint* shaders, GLint maxShaders, GLint* numShaders)
{
	GET_CONTEXT;
	ctx->glExtGetShadersQCOM(ctx, shaders, maxShaders, numShaders);
}

void glExtGetProgramsQCOM(GLuint* programs, GLint maxPrograms, GLint* numPrograms)
{
	GET_CONTEXT;
	ctx->glExtGetProgramsQCOM(ctx, programs, maxPrograms, numPrograms);
}

GLboolean glExtIsProgramBinaryQCOM(GLuint program)
{
	GET_CONTEXT;
	return ctx->glExtIsProgramBinaryQCOM(ctx, program);
}

void glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar* source, GLint* length)
{
	GET_CONTEXT;
	ctx->glExtGetProgramBinarySourceQCOM(ctx, program, shadertype, source, length);
}

void glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask)
{
	GET_CONTEXT;
	ctx->glStartTilingQCOM(ctx, x, y, width, height, preserveMask);
}

void glEndTilingQCOM(GLbitfield preserveMask)
{
	GET_CONTEXT;
	ctx->glEndTilingQCOM(ctx, preserveMask);
}

void glVertexAttribPointerData(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, void* data, GLuint datalen)
{
	GET_CONTEXT;
	ctx->glVertexAttribPointerData(ctx, indx, size, type, normalized, stride, data, datalen);
}

void glVertexAttribPointerOffset(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint offset)
{
	GET_CONTEXT;
	ctx->glVertexAttribPointerOffset(ctx, indx, size, type, normalized, stride, offset);
}

void glDrawElementsOffset(GLenum mode, GLsizei count, GLenum type, GLuint offset)
{
	GET_CONTEXT;
	ctx->glDrawElementsOffset(ctx, mode, count, type, offset);
}

void glDrawElementsData(GLenum mode, GLsizei count, GLenum type, void* data, GLuint datalen)
{
	GET_CONTEXT;
	ctx->glDrawElementsData(ctx, mode, count, type, data, datalen);
}

void glGetCompressedTextureFormats(int count, GLint* formats)
{
	GET_CONTEXT;
	ctx->glGetCompressedTextureFormats(ctx, count, formats);
}

void glShaderString(GLuint shader, const GLchar* string, GLsizei len)
{
	GET_CONTEXT;
	ctx->glShaderString(ctx, shader, string, len);
}

int glFinishRoundTrip()
{
	GET_CONTEXT;
	return ctx->glFinishRoundTrip(ctx);
}

