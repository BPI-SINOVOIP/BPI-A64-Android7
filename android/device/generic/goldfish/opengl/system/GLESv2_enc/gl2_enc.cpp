// Generated Code - DO NOT EDIT !!
// generated by 'emugen'


#include <memory>
#include <string.h>
#include "gl2_opcodes.h"

#include "gl2_enc.h"


#include <stdio.h>

namespace {

void enc_unsupported()
{
	ALOGE("Function is unsupported\n");
}

void glActiveTexture_enc(void *self , GLenum texture)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glActiveTexture;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &texture, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glAttachShader_enc(void *self , GLuint program, GLuint shader)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glAttachShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &shader, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBindAttribLocation_enc(void *self , GLuint program, GLuint index, const GLchar* name)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_name =  (strlen(name) + 1);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_name + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindAttribLocation;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &index, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_name; ptr += 4;
	memcpy(ptr, name, __size_name);ptr += __size_name;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBindBuffer_enc(void *self , GLenum target, GLuint buffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindBuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &buffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBindFramebuffer_enc(void *self , GLenum target, GLuint framebuffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindFramebuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &framebuffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBindRenderbuffer_enc(void *self , GLenum target, GLuint renderbuffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindRenderbuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &renderbuffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBindTexture_enc(void *self , GLenum target, GLuint texture)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindTexture;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &texture, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBlendColor_enc(void *self , GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBlendColor;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 4); ptr += 4;
		memcpy(ptr, &green, 4); ptr += 4;
		memcpy(ptr, &blue, 4); ptr += 4;
		memcpy(ptr, &alpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBlendEquation_enc(void *self , GLenum mode)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBlendEquation;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBlendEquationSeparate_enc(void *self , GLenum modeRGB, GLenum modeAlpha)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBlendEquationSeparate;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &modeRGB, 4); ptr += 4;
		memcpy(ptr, &modeAlpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBlendFunc_enc(void *self , GLenum sfactor, GLenum dfactor)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBlendFunc;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &sfactor, 4); ptr += 4;
		memcpy(ptr, &dfactor, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBlendFuncSeparate_enc(void *self , GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBlendFuncSeparate;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &srcRGB, 4); ptr += 4;
		memcpy(ptr, &dstRGB, 4); ptr += 4;
		memcpy(ptr, &srcAlpha, 4); ptr += 4;
		memcpy(ptr, &dstAlpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBufferData_enc(void *self , GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data = ((data != NULL) ?  size : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4);
	ptr = buf;
	int tmp = OP_glBufferData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_data,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_data,4);
	if (data != NULL) {
		stream->writeFully(data, __size_data);
		if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
	}
	buf = stream->alloc(4);
	ptr = buf;
		memcpy(ptr, &usage, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glBufferSubData_enc(void *self , GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data = ((data != NULL) ?  size : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_data + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glBufferSubData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_data,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_data,4);
	if (data != NULL) {
		stream->writeFully(data, __size_data);
		if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

GLenum glCheckFramebufferStatus_enc(void *self , GLenum target)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCheckFramebufferStatus;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLenum retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glCheckFramebufferStatus: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glClear_enc(void *self , GLbitfield mask)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClear;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mask, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClearColor_enc(void *self , GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearColor;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 4); ptr += 4;
		memcpy(ptr, &green, 4); ptr += 4;
		memcpy(ptr, &blue, 4); ptr += 4;
		memcpy(ptr, &alpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClearDepthf_enc(void *self , GLclampf depth)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearDepthf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &depth, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClearStencil_enc(void *self , GLint s)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearStencil;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &s, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glColorMask_enc(void *self , GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 1 + 1 + 1 + 1;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glColorMask;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 1); ptr += 1;
		memcpy(ptr, &green, 1); ptr += 1;
		memcpy(ptr, &blue, 1); ptr += 1;
		memcpy(ptr, &alpha, 1); ptr += 1;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glCompileShader_enc(void *self , GLuint shader)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCompileShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glCompressedTexImage2D_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data = ((data != NULL) ?  imageSize : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glCompressedTexImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
		memcpy(ptr, &imageSize, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_data,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_data,4);
	if (data != NULL) {
		stream->writeFully(data, __size_data);
		if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glCompressedTexSubImage2D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data = ((data != NULL) ?  imageSize : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glCompressedTexSubImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &imageSize, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_data,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_data,4);
	if (data != NULL) {
		stream->writeFully(data, __size_data);
		if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glCopyTexImage2D_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCopyTexImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glCopyTexSubImage2D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCopyTexSubImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

GLuint glCreateProgram_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCreateProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLuint retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glCreateProgram: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

GLuint glCreateShader_enc(void *self , GLenum type)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCreateShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &type, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLuint retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glCreateShader: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glCullFace_enc(void *self , GLenum mode)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCullFace;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteBuffers_enc(void *self , GLsizei n, const GLuint* buffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_buffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_buffers + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteBuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_buffers; ptr += 4;
	memcpy(ptr, buffers, __size_buffers);ptr += __size_buffers;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteFramebuffers_enc(void *self , GLsizei n, const GLuint* framebuffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_framebuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_framebuffers + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteFramebuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_framebuffers; ptr += 4;
	memcpy(ptr, framebuffers, __size_framebuffers);ptr += __size_framebuffers;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteProgram_enc(void *self , GLuint program)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteRenderbuffers_enc(void *self , GLsizei n, const GLuint* renderbuffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_renderbuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_renderbuffers + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteRenderbuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_renderbuffers; ptr += 4;
	memcpy(ptr, renderbuffers, __size_renderbuffers);ptr += __size_renderbuffers;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteShader_enc(void *self , GLuint shader)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteTextures_enc(void *self , GLsizei n, const GLuint* textures)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_textures =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_textures + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteTextures;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_textures; ptr += 4;
	memcpy(ptr, textures, __size_textures);ptr += __size_textures;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDepthFunc_enc(void *self , GLenum func)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDepthFunc;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &func, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDepthMask_enc(void *self , GLboolean flag)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 1;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDepthMask;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &flag, 1); ptr += 1;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDepthRangef_enc(void *self , GLclampf zNear, GLclampf zFar)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDepthRangef;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDetachShader_enc(void *self , GLuint program, GLuint shader)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDetachShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &shader, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDisable_enc(void *self , GLenum cap)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDisable;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &cap, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDisableVertexAttribArray_enc(void *self , GLuint index)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDisableVertexAttribArray;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &index, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawArrays_enc(void *self , GLenum mode, GLint first, GLsizei count)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawArrays;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
		memcpy(ptr, &first, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glEnable_enc(void *self , GLenum cap)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glEnable;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &cap, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glEnableVertexAttribArray_enc(void *self , GLuint index)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glEnableVertexAttribArray;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &index, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFinish_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFinish;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFlush_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFlush;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFramebufferRenderbuffer_enc(void *self , GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFramebufferRenderbuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &renderbuffertarget, 4); ptr += 4;
		memcpy(ptr, &renderbuffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFramebufferTexture2D_enc(void *self , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFramebufferTexture2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &textarget, 4); ptr += 4;
		memcpy(ptr, &texture, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFrontFace_enc(void *self , GLenum mode)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFrontFace;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGenBuffers_enc(void *self , GLsizei n, GLuint* buffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_buffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_buffers + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenBuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_buffers; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(buffers, __size_buffers);
	if (useChecksum) checksumCalculator->addBuffer(buffers, __size_buffers);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGenBuffers: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGenerateMipmap_enc(void *self , GLenum target)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenerateMipmap;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGenFramebuffers_enc(void *self , GLsizei n, GLuint* framebuffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_framebuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_framebuffers + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenFramebuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_framebuffers; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(framebuffers, __size_framebuffers);
	if (useChecksum) checksumCalculator->addBuffer(framebuffers, __size_framebuffers);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGenFramebuffers: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGenRenderbuffers_enc(void *self , GLsizei n, GLuint* renderbuffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_renderbuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_renderbuffers + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenRenderbuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_renderbuffers; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(renderbuffers, __size_renderbuffers);
	if (useChecksum) checksumCalculator->addBuffer(renderbuffers, __size_renderbuffers);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGenRenderbuffers: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGenTextures_enc(void *self , GLsizei n, GLuint* textures)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_textures =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_textures + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenTextures;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_textures; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(textures, __size_textures);
	if (useChecksum) checksumCalculator->addBuffer(textures, __size_textures);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGenTextures: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetActiveAttrib_enc(void *self , GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
	const unsigned int __size_size = ((size != NULL) ?  (sizeof(GLint)) : 0);
	const unsigned int __size_type = ((type != NULL) ?  (sizeof(GLenum)) : 0);
	const unsigned int __size_name = ((name != NULL) ?  bufsize : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_length + __size_size + __size_type + __size_name + 4*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetActiveAttrib;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &index, 4); ptr += 4;
		memcpy(ptr, &bufsize, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_length; ptr += 4;
	*(unsigned int *)(ptr) = __size_size; ptr += 4;
	*(unsigned int *)(ptr) = __size_type; ptr += 4;
	*(unsigned int *)(ptr) = __size_name; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	if (length != NULL) {
		stream->readback(length, __size_length);
		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
	}
	if (size != NULL) {
		stream->readback(size, __size_size);
		if (useChecksum) checksumCalculator->addBuffer(size, __size_size);
	}
	if (type != NULL) {
		stream->readback(type, __size_type);
		if (useChecksum) checksumCalculator->addBuffer(type, __size_type);
	}
	if (name != NULL) {
		stream->readback(name, __size_name);
		if (useChecksum) checksumCalculator->addBuffer(name, __size_name);
	}
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetActiveAttrib: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetActiveUniform_enc(void *self , GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
	const unsigned int __size_size = ((size != NULL) ?  (sizeof(GLint)) : 0);
	const unsigned int __size_type = ((type != NULL) ?  (sizeof(GLenum)) : 0);
	const unsigned int __size_name = ((name != NULL) ?  bufsize : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_length + __size_size + __size_type + __size_name + 4*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetActiveUniform;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &index, 4); ptr += 4;
		memcpy(ptr, &bufsize, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_length; ptr += 4;
	*(unsigned int *)(ptr) = __size_size; ptr += 4;
	*(unsigned int *)(ptr) = __size_type; ptr += 4;
	*(unsigned int *)(ptr) = __size_name; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	if (length != NULL) {
		stream->readback(length, __size_length);
		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
	}
	if (size != NULL) {
		stream->readback(size, __size_size);
		if (useChecksum) checksumCalculator->addBuffer(size, __size_size);
	}
	if (type != NULL) {
		stream->readback(type, __size_type);
		if (useChecksum) checksumCalculator->addBuffer(type, __size_type);
	}
	if (name != NULL) {
		stream->readback(name, __size_name);
		if (useChecksum) checksumCalculator->addBuffer(name, __size_name);
	}
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetActiveUniform: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetAttachedShaders_enc(void *self , GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_count = ((count != NULL) ?  (sizeof(GLsizei)) : 0);
	const unsigned int __size_shaders =  (maxcount*sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_count + __size_shaders + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetAttachedShaders;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &maxcount, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_count; ptr += 4;
	*(unsigned int *)(ptr) = __size_shaders; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	if (count != NULL) {
		stream->readback(count, __size_count);
		if (useChecksum) checksumCalculator->addBuffer(count, __size_count);
	}
	stream->readback(shaders, __size_shaders);
	if (useChecksum) checksumCalculator->addBuffer(shaders, __size_shaders);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetAttachedShaders: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

int glGetAttribLocation_enc(void *self , GLuint program, const GLchar* name)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_name =  (strlen(name) + 1);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_name + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetAttribLocation;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_name; ptr += 4;
	memcpy(ptr, name, __size_name);ptr += __size_name;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	int retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetAttribLocation: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glGetBooleanv_enc(void *self , GLenum pname, GLboolean* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLboolean));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetBooleanv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetBooleanv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetBufferParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetBufferParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetBufferParameteriv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

GLenum glGetError_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetError;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLenum retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetError: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glGetFloatv_enc(void *self , GLenum pname, GLfloat* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetFloatv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetFloatv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetFramebufferAttachmentParameteriv_enc(void *self , GLenum target, GLenum attachment, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetFramebufferAttachmentParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetFramebufferAttachmentParameteriv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetIntegerv_enc(void *self , GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetIntegerv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetIntegerv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetProgramiv_enc(void *self , GLuint program, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  sizeof(GLint);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetProgramiv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetProgramiv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetProgramInfoLog_enc(void *self , GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_length = ((length != NULL) ?  sizeof(GLsizei) : 0);
	const unsigned int __size_infolog =  bufsize;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_length + __size_infolog + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetProgramInfoLog;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &bufsize, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_length; ptr += 4;
	*(unsigned int *)(ptr) = __size_infolog; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	if (length != NULL) {
		stream->readback(length, __size_length);
		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
	}
	stream->readback(infolog, __size_infolog);
	if (useChecksum) checksumCalculator->addBuffer(infolog, __size_infolog);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetProgramInfoLog: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetRenderbufferParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  sizeof(GLint);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetRenderbufferParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetRenderbufferParameteriv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetShaderiv_enc(void *self , GLuint shader, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  sizeof(GLint);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetShaderiv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetShaderiv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetShaderInfoLog_enc(void *self , GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
	const unsigned int __size_infolog =  bufsize;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_length + __size_infolog + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetShaderInfoLog;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;
		memcpy(ptr, &bufsize, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_length; ptr += 4;
	*(unsigned int *)(ptr) = __size_infolog; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	if (length != NULL) {
		stream->readback(length, __size_length);
		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
	}
	stream->readback(infolog, __size_infolog);
	if (useChecksum) checksumCalculator->addBuffer(infolog, __size_infolog);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetShaderInfoLog: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetShaderPrecisionFormat_enc(void *self , GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_range =  (2 * sizeof(GLint));
	const unsigned int __size_precision =  (sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_range + __size_precision + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetShaderPrecisionFormat;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &shadertype, 4); ptr += 4;
		memcpy(ptr, &precisiontype, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_range; ptr += 4;
	*(unsigned int *)(ptr) = __size_precision; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(range, __size_range);
	if (useChecksum) checksumCalculator->addBuffer(range, __size_range);
	stream->readback(precision, __size_precision);
	if (useChecksum) checksumCalculator->addBuffer(precision, __size_precision);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetShaderPrecisionFormat: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetShaderSource_enc(void *self , GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
	const unsigned int __size_source =  bufsize;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_length + __size_source + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetShaderSource;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;
		memcpy(ptr, &bufsize, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_length; ptr += 4;
	*(unsigned int *)(ptr) = __size_source; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	if (length != NULL) {
		stream->readback(length, __size_length);
		if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
	}
	stream->readback(source, __size_source);
	if (useChecksum) checksumCalculator->addBuffer(source, __size_source);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetShaderSource: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetTexParameterfv_enc(void *self , GLenum target, GLenum pname, GLfloat* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexParameterfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetTexParameterfv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetTexParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetTexParameteriv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetUniformfv_enc(void *self , GLuint program, GLint location, GLfloat* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  glSizeof(glesv2_enc::uniformType(self, program, location));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetUniformfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &location, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetUniformfv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetUniformiv_enc(void *self , GLuint program, GLint location, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  glSizeof(glesv2_enc::uniformType(self, program, location));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetUniformiv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &location, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetUniformiv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

int glGetUniformLocation_enc(void *self , GLuint program, const GLchar* name)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_name =  (strlen(name) + 1);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_name + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetUniformLocation;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_name; ptr += 4;
	memcpy(ptr, name, __size_name);ptr += __size_name;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	int retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetUniformLocation: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glGetVertexAttribfv_enc(void *self , GLuint index, GLenum pname, GLfloat* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetVertexAttribfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &index, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetVertexAttribfv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetVertexAttribiv_enc(void *self , GLuint index, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetVertexAttribiv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &index, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetVertexAttribiv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glHint_enc(void *self , GLenum target, GLenum mode)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glHint;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &mode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

GLboolean glIsBuffer_enc(void *self , GLuint buffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsBuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &buffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glIsBuffer: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

GLboolean glIsEnabled_enc(void *self , GLenum cap)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsEnabled;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &cap, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glIsEnabled: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

GLboolean glIsFramebuffer_enc(void *self , GLuint framebuffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsFramebuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &framebuffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glIsFramebuffer: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

GLboolean glIsProgram_enc(void *self , GLuint program)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glIsProgram: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

GLboolean glIsRenderbuffer_enc(void *self , GLuint renderbuffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsRenderbuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &renderbuffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glIsRenderbuffer: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

GLboolean glIsShader_enc(void *self , GLuint shader)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glIsShader: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

GLboolean glIsTexture_enc(void *self , GLuint texture)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsTexture;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &texture, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glIsTexture: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glLineWidth_enc(void *self , GLfloat width)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLineWidth;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &width, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLinkProgram_enc(void *self , GLuint program)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLinkProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPixelStorei_enc(void *self , GLenum pname, GLint param)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPixelStorei;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPolygonOffset_enc(void *self , GLfloat factor, GLfloat units)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPolygonOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &factor, 4); ptr += 4;
		memcpy(ptr, &units, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glReadPixels_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_pixels =  glesv2_enc::pixelDataSize(self, width, height, format, type, 1);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glReadPixels;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_pixels; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(pixels, __size_pixels);
	if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glReadPixels: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glReleaseShaderCompiler_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glReleaseShaderCompiler;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glRenderbufferStorage_enc(void *self , GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glRenderbufferStorage;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glSampleCoverage_enc(void *self , GLclampf value, GLboolean invert)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 1;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glSampleCoverage;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &value, 4); ptr += 4;
		memcpy(ptr, &invert, 1); ptr += 1;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glScissor_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glScissor;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glStencilFunc_enc(void *self , GLenum func, GLint ref, GLuint mask)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glStencilFunc;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &func, 4); ptr += 4;
		memcpy(ptr, &ref, 4); ptr += 4;
		memcpy(ptr, &mask, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glStencilFuncSeparate_enc(void *self , GLenum face, GLenum func, GLint ref, GLuint mask)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glStencilFuncSeparate;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &func, 4); ptr += 4;
		memcpy(ptr, &ref, 4); ptr += 4;
		memcpy(ptr, &mask, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glStencilMask_enc(void *self , GLuint mask)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glStencilMask;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mask, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glStencilMaskSeparate_enc(void *self , GLenum face, GLuint mask)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glStencilMaskSeparate;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &mask, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glStencilOp_enc(void *self , GLenum fail, GLenum zfail, GLenum zpass)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glStencilOp;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &fail, 4); ptr += 4;
		memcpy(ptr, &zfail, 4); ptr += 4;
		memcpy(ptr, &zpass, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glStencilOpSeparate_enc(void *self , GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glStencilOpSeparate;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &fail, 4); ptr += 4;
		memcpy(ptr, &zfail, 4); ptr += 4;
		memcpy(ptr, &zpass, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexImage2D_enc(void *self , GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_pixels = ((pixels != NULL) ?  glesv2_enc::pixelDataSize(self, width, height, format, type, 0) : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glTexImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_pixels,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_pixels,4);
	if (pixels != NULL) {
		stream->writeFully(pixels, __size_pixels);
		if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glTexParameterf_enc(void *self , GLenum target, GLenum pname, GLfloat param)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameterf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexParameterfv_enc(void *self , GLenum target, GLenum pname, const GLfloat* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameterfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexParameteri_enc(void *self , GLenum target, GLenum pname, GLint param)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameteri;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexParameteriv_enc(void *self , GLenum target, GLenum pname, const GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexSubImage2D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_pixels = ((pixels != NULL) ?  glesv2_enc::pixelDataSize(self, width, height, format, type, 0) : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glTexSubImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_pixels,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_pixels,4);
	if (pixels != NULL) {
		stream->writeFully(pixels, __size_pixels);
		if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glUniform1f_enc(void *self , GLint location, GLfloat x)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform1f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform1fv_enc(void *self , GLint location, GLsizei count, const GLfloat* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_v =  (count * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_v + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform1fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform1i_enc(void *self , GLint location, GLint x)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform1i;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform1iv_enc(void *self , GLint location, GLsizei count, const GLint* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_v =  (count * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_v + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform1iv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform2f_enc(void *self , GLint location, GLfloat x, GLfloat y)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform2f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform2fv_enc(void *self , GLint location, GLsizei count, const GLfloat* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_v =  (count * 2 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_v + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform2fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform2i_enc(void *self , GLint location, GLint x, GLint y)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform2i;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform2iv_enc(void *self , GLint location, GLsizei count, const GLint* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_v =  (count * 2 * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_v + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform2iv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform3f_enc(void *self , GLint location, GLfloat x, GLfloat y, GLfloat z)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform3f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform3fv_enc(void *self , GLint location, GLsizei count, const GLfloat* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_v =  (count * 3 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_v + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform3fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform3i_enc(void *self , GLint location, GLint x, GLint y, GLint z)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform3i;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform3iv_enc(void *self , GLint location, GLsizei count, const GLint* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_v =  (3 * count * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_v + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform3iv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform4f_enc(void *self , GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform4f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
		memcpy(ptr, &w, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform4fv_enc(void *self , GLint location, GLsizei count, const GLfloat* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_v =  (4 * count * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_v + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform4fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform4i_enc(void *self , GLint location, GLint x, GLint y, GLint z, GLint w)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform4i;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
		memcpy(ptr, &w, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniform4iv_enc(void *self , GLint location, GLsizei count, const GLint* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_v =  (4 * count * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_v + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniform4iv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniformMatrix2fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_value =  (count * 4 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 1 + __size_value + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniformMatrix2fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &transpose, 1); ptr += 1;
	*(unsigned int *)(ptr) = __size_value; ptr += 4;
	memcpy(ptr, value, __size_value);ptr += __size_value;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniformMatrix3fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_value =  (count * 9 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 1 + __size_value + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniformMatrix3fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &transpose, 1); ptr += 1;
	*(unsigned int *)(ptr) = __size_value; ptr += 4;
	memcpy(ptr, value, __size_value);ptr += __size_value;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUniformMatrix4fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_value =  (count * 16 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 1 + __size_value + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUniformMatrix4fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &transpose, 1); ptr += 1;
	*(unsigned int *)(ptr) = __size_value; ptr += 4;
	memcpy(ptr, value, __size_value);ptr += __size_value;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glUseProgram_enc(void *self , GLuint program)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUseProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glValidateProgram_enc(void *self , GLuint program)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glValidateProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexAttrib1f_enc(void *self , GLuint indx, GLfloat x)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexAttrib1f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexAttrib1fv_enc(void *self , GLuint indx, const GLfloat* values)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_values =  (sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_values + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexAttrib1fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_values; ptr += 4;
	memcpy(ptr, values, __size_values);ptr += __size_values;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexAttrib2f_enc(void *self , GLuint indx, GLfloat x, GLfloat y)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexAttrib2f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexAttrib2fv_enc(void *self , GLuint indx, const GLfloat* values)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_values =  (2 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_values + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexAttrib2fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_values; ptr += 4;
	memcpy(ptr, values, __size_values);ptr += __size_values;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexAttrib3f_enc(void *self , GLuint indx, GLfloat x, GLfloat y, GLfloat z)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexAttrib3f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexAttrib3fv_enc(void *self , GLuint indx, const GLfloat* values)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_values =  (3 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_values + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexAttrib3fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_values; ptr += 4;
	memcpy(ptr, values, __size_values);ptr += __size_values;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexAttrib4f_enc(void *self , GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexAttrib4f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
		memcpy(ptr, &w, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexAttrib4fv_enc(void *self , GLuint indx, const GLfloat* values)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_values =  (4 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_values + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexAttrib4fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_values; ptr += 4;
	memcpy(ptr, values, __size_values);ptr += __size_values;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glViewport_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glViewport;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glEGLImageTargetTexture2DOES_enc(void *self , GLenum target, GLeglImageOES image)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glEGLImageTargetTexture2DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &image, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glEGLImageTargetRenderbufferStorageOES_enc(void *self , GLenum target, GLeglImageOES image)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glEGLImageTargetRenderbufferStorageOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &image, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

GLboolean glUnmapBufferOES_enc(void *self , GLenum target)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUnmapBufferOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glUnmapBufferOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glTexImage3DOES_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* pixels)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_pixels = ((pixels != NULL) ?  glesv2_enc::pixelDataSize3D(self, width, height, depth, format, type, 0) : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glTexImage3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &depth, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_pixels,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_pixels,4);
	if (pixels != NULL) {
		stream->writeFully(pixels, __size_pixels);
		if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glTexSubImage3DOES_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* pixels)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_pixels = ((pixels != NULL) ?  glesv2_enc::pixelDataSize3D(self, width, height, depth, format, type, 0) : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glTexSubImage3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &zoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &depth, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_pixels,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_pixels,4);
	if (pixels != NULL) {
		stream->writeFully(pixels, __size_pixels);
		if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glCopyTexSubImage3DOES_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCopyTexSubImage3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &zoffset, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glCompressedTexImage3DOES_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data = ((data != NULL) ?  imageSize : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glCompressedTexImage3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &depth, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
		memcpy(ptr, &imageSize, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_data,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_data,4);
	if (data != NULL) {
		stream->writeFully(data, __size_data);
		if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glCompressedTexSubImage3DOES_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data = ((data != NULL) ?  imageSize : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glCompressedTexSubImage3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &zoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &depth, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &imageSize, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_data,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_data,4);
	if (data != NULL) {
		stream->writeFully(data, __size_data);
		if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glFramebufferTexture3DOES_enc(void *self , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFramebufferTexture3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &textarget, 4); ptr += 4;
		memcpy(ptr, &texture, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &zoffset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBindVertexArrayOES_enc(void *self , GLuint array)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindVertexArrayOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &array, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteVertexArraysOES_enc(void *self , GLsizei n, const GLuint* arrays)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_arrays =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_arrays + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteVertexArraysOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_arrays; ptr += 4;
	memcpy(ptr, arrays, __size_arrays);ptr += __size_arrays;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGenVertexArraysOES_enc(void *self , GLsizei n, GLuint* arrays)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_arrays =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_arrays + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenVertexArraysOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_arrays; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(arrays, __size_arrays);
	if (useChecksum) checksumCalculator->addBuffer(arrays, __size_arrays);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGenVertexArraysOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

GLboolean glIsVertexArrayOES_enc(void *self , GLuint array)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsVertexArrayOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &array, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glIsVertexArrayOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glDiscardFramebufferEXT_enc(void *self , GLenum target, GLsizei numAttachments, const GLenum* attachments)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_attachments =  (numAttachments * sizeof(GLenum));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_attachments + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDiscardFramebufferEXT;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &numAttachments, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_attachments; ptr += 4;
	memcpy(ptr, attachments, __size_attachments);ptr += __size_attachments;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexAttribPointerData_enc(void *self , GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, void* data, GLuint datalen)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexAttribPointerData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &normalized, 1); ptr += 1;
		memcpy(ptr, &stride, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_data; ptr += 4;
	 glUtilsPackPointerData((unsigned char *)ptr, (unsigned char *)data, size, type, stride, datalen);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexAttribPointerOffset_enc(void *self , GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint offset)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 1 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexAttribPointerOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &normalized, 1); ptr += 1;
		memcpy(ptr, &stride, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawElementsOffset_enc(void *self , GLenum mode, GLsizei count, GLenum type, GLuint offset)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawElementsOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawElementsData_enc(void *self , GLenum mode, GLsizei count, GLenum type, void* data, GLuint datalen)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawElementsData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_data; ptr += 4;
	memcpy(ptr, data, __size_data);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetCompressedTextureFormats_enc(void *self , int count, GLint* formats)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_formats =  (count * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_formats + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetCompressedTextureFormats;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_formats; ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(formats, __size_formats);
	if (useChecksum) checksumCalculator->addBuffer(formats, __size_formats);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glGetCompressedTextureFormats: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glShaderString_enc(void *self , GLuint shader, const GLchar* string, GLsizei len)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_string =  len;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_string + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glShaderString;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_string; ptr += 4;
	memcpy(ptr, string, __size_string);ptr += __size_string;
		memcpy(ptr, &len, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

int glFinishRoundTrip_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFinishRoundTrip;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	int retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		std::unique_ptr<unsigned char[]> checksumBuf(new unsigned char[checksumSize]);
		stream->readback(checksumBuf.get(), checksumSize);
		if (!checksumCalculator->validate(checksumBuf.get(), checksumSize)) {
			ALOGE("glFinishRoundTrip: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

}  // namespace

gl2_encoder_context_t::gl2_encoder_context_t(IOStream *stream, ChecksumCalculator *checksumCalculator)
{
	m_stream = stream;
	m_checksumCalculator = checksumCalculator;

	this->glActiveTexture = &glActiveTexture_enc;
	this->glAttachShader = &glAttachShader_enc;
	this->glBindAttribLocation = &glBindAttribLocation_enc;
	this->glBindBuffer = &glBindBuffer_enc;
	this->glBindFramebuffer = &glBindFramebuffer_enc;
	this->glBindRenderbuffer = &glBindRenderbuffer_enc;
	this->glBindTexture = &glBindTexture_enc;
	this->glBlendColor = &glBlendColor_enc;
	this->glBlendEquation = &glBlendEquation_enc;
	this->glBlendEquationSeparate = &glBlendEquationSeparate_enc;
	this->glBlendFunc = &glBlendFunc_enc;
	this->glBlendFuncSeparate = &glBlendFuncSeparate_enc;
	this->glBufferData = &glBufferData_enc;
	this->glBufferSubData = &glBufferSubData_enc;
	this->glCheckFramebufferStatus = &glCheckFramebufferStatus_enc;
	this->glClear = &glClear_enc;
	this->glClearColor = &glClearColor_enc;
	this->glClearDepthf = &glClearDepthf_enc;
	this->glClearStencil = &glClearStencil_enc;
	this->glColorMask = &glColorMask_enc;
	this->glCompileShader = &glCompileShader_enc;
	this->glCompressedTexImage2D = &glCompressedTexImage2D_enc;
	this->glCompressedTexSubImage2D = &glCompressedTexSubImage2D_enc;
	this->glCopyTexImage2D = &glCopyTexImage2D_enc;
	this->glCopyTexSubImage2D = &glCopyTexSubImage2D_enc;
	this->glCreateProgram = &glCreateProgram_enc;
	this->glCreateShader = &glCreateShader_enc;
	this->glCullFace = &glCullFace_enc;
	this->glDeleteBuffers = &glDeleteBuffers_enc;
	this->glDeleteFramebuffers = &glDeleteFramebuffers_enc;
	this->glDeleteProgram = &glDeleteProgram_enc;
	this->glDeleteRenderbuffers = &glDeleteRenderbuffers_enc;
	this->glDeleteShader = &glDeleteShader_enc;
	this->glDeleteTextures = &glDeleteTextures_enc;
	this->glDepthFunc = &glDepthFunc_enc;
	this->glDepthMask = &glDepthMask_enc;
	this->glDepthRangef = &glDepthRangef_enc;
	this->glDetachShader = &glDetachShader_enc;
	this->glDisable = &glDisable_enc;
	this->glDisableVertexAttribArray = &glDisableVertexAttribArray_enc;
	this->glDrawArrays = &glDrawArrays_enc;
	this->glDrawElements = (glDrawElements_client_proc_t) &enc_unsupported;
	this->glEnable = &glEnable_enc;
	this->glEnableVertexAttribArray = &glEnableVertexAttribArray_enc;
	this->glFinish = &glFinish_enc;
	this->glFlush = &glFlush_enc;
	this->glFramebufferRenderbuffer = &glFramebufferRenderbuffer_enc;
	this->glFramebufferTexture2D = &glFramebufferTexture2D_enc;
	this->glFrontFace = &glFrontFace_enc;
	this->glGenBuffers = &glGenBuffers_enc;
	this->glGenerateMipmap = &glGenerateMipmap_enc;
	this->glGenFramebuffers = &glGenFramebuffers_enc;
	this->glGenRenderbuffers = &glGenRenderbuffers_enc;
	this->glGenTextures = &glGenTextures_enc;
	this->glGetActiveAttrib = &glGetActiveAttrib_enc;
	this->glGetActiveUniform = &glGetActiveUniform_enc;
	this->glGetAttachedShaders = &glGetAttachedShaders_enc;
	this->glGetAttribLocation = &glGetAttribLocation_enc;
	this->glGetBooleanv = &glGetBooleanv_enc;
	this->glGetBufferParameteriv = &glGetBufferParameteriv_enc;
	this->glGetError = &glGetError_enc;
	this->glGetFloatv = &glGetFloatv_enc;
	this->glGetFramebufferAttachmentParameteriv = &glGetFramebufferAttachmentParameteriv_enc;
	this->glGetIntegerv = &glGetIntegerv_enc;
	this->glGetProgramiv = &glGetProgramiv_enc;
	this->glGetProgramInfoLog = &glGetProgramInfoLog_enc;
	this->glGetRenderbufferParameteriv = &glGetRenderbufferParameteriv_enc;
	this->glGetShaderiv = &glGetShaderiv_enc;
	this->glGetShaderInfoLog = &glGetShaderInfoLog_enc;
	this->glGetShaderPrecisionFormat = &glGetShaderPrecisionFormat_enc;
	this->glGetShaderSource = &glGetShaderSource_enc;
	this->glGetString = (glGetString_client_proc_t) &enc_unsupported;
	this->glGetTexParameterfv = &glGetTexParameterfv_enc;
	this->glGetTexParameteriv = &glGetTexParameteriv_enc;
	this->glGetUniformfv = &glGetUniformfv_enc;
	this->glGetUniformiv = &glGetUniformiv_enc;
	this->glGetUniformLocation = &glGetUniformLocation_enc;
	this->glGetVertexAttribfv = &glGetVertexAttribfv_enc;
	this->glGetVertexAttribiv = &glGetVertexAttribiv_enc;
	this->glGetVertexAttribPointerv = (glGetVertexAttribPointerv_client_proc_t) &enc_unsupported;
	this->glHint = &glHint_enc;
	this->glIsBuffer = &glIsBuffer_enc;
	this->glIsEnabled = &glIsEnabled_enc;
	this->glIsFramebuffer = &glIsFramebuffer_enc;
	this->glIsProgram = &glIsProgram_enc;
	this->glIsRenderbuffer = &glIsRenderbuffer_enc;
	this->glIsShader = &glIsShader_enc;
	this->glIsTexture = &glIsTexture_enc;
	this->glLineWidth = &glLineWidth_enc;
	this->glLinkProgram = &glLinkProgram_enc;
	this->glPixelStorei = &glPixelStorei_enc;
	this->glPolygonOffset = &glPolygonOffset_enc;
	this->glReadPixels = &glReadPixels_enc;
	this->glReleaseShaderCompiler = &glReleaseShaderCompiler_enc;
	this->glRenderbufferStorage = &glRenderbufferStorage_enc;
	this->glSampleCoverage = &glSampleCoverage_enc;
	this->glScissor = &glScissor_enc;
	this->glShaderBinary = (glShaderBinary_client_proc_t) &enc_unsupported;
	this->glShaderSource = (glShaderSource_client_proc_t) &enc_unsupported;
	this->glStencilFunc = &glStencilFunc_enc;
	this->glStencilFuncSeparate = &glStencilFuncSeparate_enc;
	this->glStencilMask = &glStencilMask_enc;
	this->glStencilMaskSeparate = &glStencilMaskSeparate_enc;
	this->glStencilOp = &glStencilOp_enc;
	this->glStencilOpSeparate = &glStencilOpSeparate_enc;
	this->glTexImage2D = &glTexImage2D_enc;
	this->glTexParameterf = &glTexParameterf_enc;
	this->glTexParameterfv = &glTexParameterfv_enc;
	this->glTexParameteri = &glTexParameteri_enc;
	this->glTexParameteriv = &glTexParameteriv_enc;
	this->glTexSubImage2D = &glTexSubImage2D_enc;
	this->glUniform1f = &glUniform1f_enc;
	this->glUniform1fv = &glUniform1fv_enc;
	this->glUniform1i = &glUniform1i_enc;
	this->glUniform1iv = &glUniform1iv_enc;
	this->glUniform2f = &glUniform2f_enc;
	this->glUniform2fv = &glUniform2fv_enc;
	this->glUniform2i = &glUniform2i_enc;
	this->glUniform2iv = &glUniform2iv_enc;
	this->glUniform3f = &glUniform3f_enc;
	this->glUniform3fv = &glUniform3fv_enc;
	this->glUniform3i = &glUniform3i_enc;
	this->glUniform3iv = &glUniform3iv_enc;
	this->glUniform4f = &glUniform4f_enc;
	this->glUniform4fv = &glUniform4fv_enc;
	this->glUniform4i = &glUniform4i_enc;
	this->glUniform4iv = &glUniform4iv_enc;
	this->glUniformMatrix2fv = &glUniformMatrix2fv_enc;
	this->glUniformMatrix3fv = &glUniformMatrix3fv_enc;
	this->glUniformMatrix4fv = &glUniformMatrix4fv_enc;
	this->glUseProgram = &glUseProgram_enc;
	this->glValidateProgram = &glValidateProgram_enc;
	this->glVertexAttrib1f = &glVertexAttrib1f_enc;
	this->glVertexAttrib1fv = &glVertexAttrib1fv_enc;
	this->glVertexAttrib2f = &glVertexAttrib2f_enc;
	this->glVertexAttrib2fv = &glVertexAttrib2fv_enc;
	this->glVertexAttrib3f = &glVertexAttrib3f_enc;
	this->glVertexAttrib3fv = &glVertexAttrib3fv_enc;
	this->glVertexAttrib4f = &glVertexAttrib4f_enc;
	this->glVertexAttrib4fv = &glVertexAttrib4fv_enc;
	this->glVertexAttribPointer = (glVertexAttribPointer_client_proc_t) &enc_unsupported;
	this->glViewport = &glViewport_enc;
	this->glEGLImageTargetTexture2DOES = &glEGLImageTargetTexture2DOES_enc;
	this->glEGLImageTargetRenderbufferStorageOES = &glEGLImageTargetRenderbufferStorageOES_enc;
	this->glGetProgramBinaryOES = (glGetProgramBinaryOES_client_proc_t) &enc_unsupported;
	this->glProgramBinaryOES = (glProgramBinaryOES_client_proc_t) &enc_unsupported;
	this->glMapBufferOES = (glMapBufferOES_client_proc_t) &enc_unsupported;
	this->glUnmapBufferOES = &glUnmapBufferOES_enc;
	this->glTexImage3DOES = &glTexImage3DOES_enc;
	this->glTexSubImage3DOES = &glTexSubImage3DOES_enc;
	this->glCopyTexSubImage3DOES = &glCopyTexSubImage3DOES_enc;
	this->glCompressedTexImage3DOES = &glCompressedTexImage3DOES_enc;
	this->glCompressedTexSubImage3DOES = &glCompressedTexSubImage3DOES_enc;
	this->glFramebufferTexture3DOES = &glFramebufferTexture3DOES_enc;
	this->glBindVertexArrayOES = &glBindVertexArrayOES_enc;
	this->glDeleteVertexArraysOES = &glDeleteVertexArraysOES_enc;
	this->glGenVertexArraysOES = &glGenVertexArraysOES_enc;
	this->glIsVertexArrayOES = &glIsVertexArrayOES_enc;
	this->glDiscardFramebufferEXT = &glDiscardFramebufferEXT_enc;
	this->glMultiDrawArraysEXT = (glMultiDrawArraysEXT_client_proc_t) &enc_unsupported;
	this->glMultiDrawElementsEXT = (glMultiDrawElementsEXT_client_proc_t) &enc_unsupported;
	this->glGetPerfMonitorGroupsAMD = (glGetPerfMonitorGroupsAMD_client_proc_t) &enc_unsupported;
	this->glGetPerfMonitorCountersAMD = (glGetPerfMonitorCountersAMD_client_proc_t) &enc_unsupported;
	this->glGetPerfMonitorGroupStringAMD = (glGetPerfMonitorGroupStringAMD_client_proc_t) &enc_unsupported;
	this->glGetPerfMonitorCounterStringAMD = (glGetPerfMonitorCounterStringAMD_client_proc_t) &enc_unsupported;
	this->glGetPerfMonitorCounterInfoAMD = (glGetPerfMonitorCounterInfoAMD_client_proc_t) &enc_unsupported;
	this->glGenPerfMonitorsAMD = (glGenPerfMonitorsAMD_client_proc_t) &enc_unsupported;
	this->glDeletePerfMonitorsAMD = (glDeletePerfMonitorsAMD_client_proc_t) &enc_unsupported;
	this->glSelectPerfMonitorCountersAMD = (glSelectPerfMonitorCountersAMD_client_proc_t) &enc_unsupported;
	this->glBeginPerfMonitorAMD = (glBeginPerfMonitorAMD_client_proc_t) &enc_unsupported;
	this->glEndPerfMonitorAMD = (glEndPerfMonitorAMD_client_proc_t) &enc_unsupported;
	this->glGetPerfMonitorCounterDataAMD = (glGetPerfMonitorCounterDataAMD_client_proc_t) &enc_unsupported;
	this->glRenderbufferStorageMultisampleIMG = (glRenderbufferStorageMultisampleIMG_client_proc_t) &enc_unsupported;
	this->glFramebufferTexture2DMultisampleIMG = (glFramebufferTexture2DMultisampleIMG_client_proc_t) &enc_unsupported;
	this->glDeleteFencesNV = (glDeleteFencesNV_client_proc_t) &enc_unsupported;
	this->glGenFencesNV = (glGenFencesNV_client_proc_t) &enc_unsupported;
	this->glIsFenceNV = (glIsFenceNV_client_proc_t) &enc_unsupported;
	this->glTestFenceNV = (glTestFenceNV_client_proc_t) &enc_unsupported;
	this->glGetFenceivNV = (glGetFenceivNV_client_proc_t) &enc_unsupported;
	this->glFinishFenceNV = (glFinishFenceNV_client_proc_t) &enc_unsupported;
	this->glSetFenceNV = (glSetFenceNV_client_proc_t) &enc_unsupported;
	this->glCoverageMaskNV = (glCoverageMaskNV_client_proc_t) &enc_unsupported;
	this->glCoverageOperationNV = (glCoverageOperationNV_client_proc_t) &enc_unsupported;
	this->glGetDriverControlsQCOM = (glGetDriverControlsQCOM_client_proc_t) &enc_unsupported;
	this->glGetDriverControlStringQCOM = (glGetDriverControlStringQCOM_client_proc_t) &enc_unsupported;
	this->glEnableDriverControlQCOM = (glEnableDriverControlQCOM_client_proc_t) &enc_unsupported;
	this->glDisableDriverControlQCOM = (glDisableDriverControlQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetTexturesQCOM = (glExtGetTexturesQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetBuffersQCOM = (glExtGetBuffersQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetRenderbuffersQCOM = (glExtGetRenderbuffersQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetFramebuffersQCOM = (glExtGetFramebuffersQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetTexLevelParameterivQCOM = (glExtGetTexLevelParameterivQCOM_client_proc_t) &enc_unsupported;
	this->glExtTexObjectStateOverrideiQCOM = (glExtTexObjectStateOverrideiQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetTexSubImageQCOM = (glExtGetTexSubImageQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetBufferPointervQCOM = (glExtGetBufferPointervQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetShadersQCOM = (glExtGetShadersQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetProgramsQCOM = (glExtGetProgramsQCOM_client_proc_t) &enc_unsupported;
	this->glExtIsProgramBinaryQCOM = (glExtIsProgramBinaryQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetProgramBinarySourceQCOM = (glExtGetProgramBinarySourceQCOM_client_proc_t) &enc_unsupported;
	this->glStartTilingQCOM = (glStartTilingQCOM_client_proc_t) &enc_unsupported;
	this->glEndTilingQCOM = (glEndTilingQCOM_client_proc_t) &enc_unsupported;
	this->glVertexAttribPointerData = &glVertexAttribPointerData_enc;
	this->glVertexAttribPointerOffset = &glVertexAttribPointerOffset_enc;
	this->glDrawElementsOffset = &glDrawElementsOffset_enc;
	this->glDrawElementsData = &glDrawElementsData_enc;
	this->glGetCompressedTextureFormats = &glGetCompressedTextureFormats_enc;
	this->glShaderString = &glShaderString_enc;
	this->glFinishRoundTrip = &glFinishRoundTrip_enc;
}

