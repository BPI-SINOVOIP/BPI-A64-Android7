/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.support.test.aupt;

import android.util.Log;

import java.lang.StringBuilder;
import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.json.JSONObject;
import org.json.JSONException;

/**
 * This class is like a C-style struct that holds individual process information from the
 * dumpsys graphicsstats command. It also includes an enumeration, originally from the
 * JankTestHelper code, which pattern matches against the dump data to find the relevant
 * information.
 */
public class JankStat {
    private static final String TAG = "JankStat";

    // Patterns used for parsing dumpsys graphicsstats
    public enum StatPattern {
        PACKAGE("package",
                Pattern.compile("\\s*Package: (.*)"), 1),

        STATS_SINCE("startTime",
                Pattern.compile("\\s*Stats since: (\\d+)ns"), 1),

        TOTAL_FRAMES("frameCount",
                Pattern.compile("\\s*Total frames rendered: (\\d+)"), 1),

        NUM_JANKY("jankyCount",
                Pattern.compile("\\s*Janky frames: (\\d+) (.*)"), 1),

        FRAME_TIME_50TH("percentile50",
                Pattern.compile("\\s*50th percentile: (\\d+)ms"), 1),

        FRAME_TIME_90TH("percentile90",
                Pattern.compile("\\s*90th percentile: (\\d+)ms"), 1),

        FRAME_TIME_95TH("percentile95",
                Pattern.compile("\\s*95th percentile: (\\d+)ms"), 1),

        FRAME_TIME_99TH("percentile99",
                Pattern.compile("\\s*99th percentile: (\\d+)ms"), 1),

        NUM_MISSED_VSYNC("missedVsyncCount",
                Pattern.compile("\\s*Number Missed Vsync: (\\d+)"), 1),

        NUM_HIGH_INPUT_LATENCY("highLatencyCount",
                Pattern.compile("\\s*Number High input latency: (\\d+)"), 1),

        NUM_SLOW_UI_THREAD("slowUIThreadCount",
                Pattern.compile("\\s*Number Slow UI thread: (\\d+)"), 1),

        NUM_SLOW_BITMAP_UPLOADS("slowBitmapUploadCount",
                Pattern.compile("\\s*Number Slow bitmap uploads: (\\d+)"), 1),

        NUM_SLOW_DRAW("slowDrawCmdCount",
                Pattern.compile("\\s*Number Slow issue draw commands: (\\d+)"), 1),

        AGGREGATE_COUNT("aggregateCount", null, 1);

        private String mName;
        private Pattern mParsePattern;
        private int mGroupIdx;

        /**
         * Constructs each pattern for parsing the statistics
         * generated by `dumpsys graphicsstats`
         *
         * "name" is a unique JSON key for the field
         * "pattern" is the regex for parsing out the field
         * "idx" the match-index for the relevant field in that pattern
         */
        StatPattern(String name, Pattern pattern, int idx) {
            mName = name;
            mParsePattern = pattern;
            mGroupIdx = idx;
        }

        String parse(String line) {
            String ret = null;
            Matcher matcher = mParsePattern.matcher(line);
            if (matcher.matches()) {
                ret = matcher.group(mGroupIdx);
            }
            return ret;
        }

        Pattern getPattern() {
            return mParsePattern;
        }

        String getName() {
            return mName;
        }
    }

    public String packageName;
    public Long statsSince;
    public Integer totalFrames;
    public Integer jankyFrames;
    public Integer frameTime50th;
    public Integer frameTime90th;
    public Integer frameTime95th;
    public Integer frameTime99th;
    public Integer numMissedVsync;
    public Integer numHighLatency;
    public Integer numSlowUiThread;
    public Integer numSlowBitmap;
    public Integer numSlowDraw;
    public Integer aggregateCount;

    public JankStat (String pkg, long since, int total, int janky, int ft50, int ft90, int ft95,
            int ft99, int vsync, int latency, int slowUi, int slowBmp, int slowDraw,
            int aggCount) {
        packageName = pkg;
        statsSince = since;
        totalFrames = total;
        jankyFrames = janky;
        frameTime50th = ft50;
        frameTime90th = ft90;
        frameTime95th = ft95;
        frameTime99th = ft99;
        numMissedVsync = vsync;
        numHighLatency = latency;
        numSlowUiThread = slowUi;
        numSlowBitmap = slowBmp;
        numSlowDraw = slowDraw;
        aggregateCount = aggCount;
    }

    /**
     * Determines if this set of janks stats is aggregated from the
     * previous set of metrics or if they are a new set, meaning the
     * old process was killed, had its stats reset, and was then
     * restarted.
     */
    public boolean isContinuedFrom (JankStat prevMetrics) {
        return statsSince == prevMetrics.statsSince;
    }

    /**
     * Returns the percent of frames that appeared janky
     */
    public float getPercentJankyFrames () {
        return jankyFrames / (float)totalFrames;
    }

    /**
     * Serialize this object into a JSONObject
     */
    public JSONObject toJson () throws JSONException {
        return new JSONObject().
                put(StatPattern.PACKAGE.getName(), packageName).
                put(StatPattern.STATS_SINCE.getName(), statsSince).
                put(StatPattern.TOTAL_FRAMES.getName(), totalFrames).
                put(StatPattern.NUM_JANKY.getName(), jankyFrames).
                put(StatPattern.FRAME_TIME_50TH.getName(), frameTime50th).
                put(StatPattern.FRAME_TIME_90TH.getName(), frameTime90th).
                put(StatPattern.FRAME_TIME_95TH.getName(), frameTime95th).
                put(StatPattern.FRAME_TIME_99TH.getName(), frameTime99th).
                put(StatPattern.NUM_MISSED_VSYNC.getName(), numMissedVsync).
                put(StatPattern.NUM_HIGH_INPUT_LATENCY.getName(), numHighLatency).
                put(StatPattern.NUM_SLOW_UI_THREAD.getName(), numSlowUiThread).
                put(StatPattern.NUM_SLOW_BITMAP_UPLOADS.getName(), numSlowBitmap).
                put(StatPattern.NUM_SLOW_DRAW.getName(), numSlowDraw).
                put(StatPattern.AGGREGATE_COUNT.getName(), aggregateCount);
    }

    /**
     * @{inheritDoc}
     */
    @Override
    public String toString () {
      try {
        return toJson().toString(4);
      } catch (JSONException e) {
        throw new RuntimeException("Error serializing JankStat: " + e.toString());
      }
    }

    /**
     * Merges the stat history of a sequence of stats.
     *
     * Final count value = sum of count values across stats
     * Final ##th percentile = weighted average of ##th, weight by total frames
     *     ## = 90, 95, and 99
     */
    public static JankStat mergeStatHistory (List<JankStat> statHistory) {
        if (statHistory.size() == 0)
            return null;
        else if (statHistory.size() == 1)
            return statHistory.get(0);

        String pkg = statHistory.get(0).packageName;
        long totalStatsSince = statHistory.get(0).statsSince;
        int totalTotalFrames = 0;
        int totalJankyFrames = 0;
        int totalNumMissedVsync = 0;
        int totalNumHighLatency = 0;
        int totalNumSlowUiThread = 0;
        int totalNumSlowBitmap = 0;
        int totalNumSlowDraw = 0;

        for (JankStat stat : statHistory) {
            totalTotalFrames += stat.totalFrames;
            totalJankyFrames += stat.jankyFrames;
            totalNumMissedVsync += stat.numMissedVsync;
            totalNumHighLatency += stat.numHighLatency;
            totalNumSlowUiThread += stat.numSlowUiThread;
            totalNumSlowBitmap += stat.numSlowBitmap;
            totalNumSlowDraw += stat.numSlowDraw;
        }

        float wgtAvgPercentile50 = 0f;
        float wgtAvgPercentile90 = 0f;
        float wgtAvgPercentile95 = 0f;
        float wgtAvgPercentile99 = 0f;

        for (JankStat stat : statHistory) {
            float weight = ((float)stat.totalFrames / totalTotalFrames);
            Log.v(TAG, String.format("Calculated weight is %f", weight));
            wgtAvgPercentile50 += stat.frameTime50th * weight;
            wgtAvgPercentile90 += stat.frameTime90th * weight;
            wgtAvgPercentile95 += stat.frameTime95th * weight;
            wgtAvgPercentile99 += stat.frameTime99th * weight;
        }

        int perc50 = (int)Math.ceil(wgtAvgPercentile50);
        int perc90 = (int)Math.ceil(wgtAvgPercentile90);
        int perc95 = (int)Math.ceil(wgtAvgPercentile95);
        int perc99 = (int)Math.ceil(wgtAvgPercentile99);

        return new JankStat(pkg, totalStatsSince, totalTotalFrames,
                totalJankyFrames, perc50, perc90, perc95, perc99,
                totalNumMissedVsync, totalNumHighLatency, totalNumSlowUiThread, totalNumSlowBitmap,
                totalNumSlowDraw, statHistory.size());
    }

    /**
     * Returns a long String containing each JankStat object separated by a
     * newline. Ideally, this would omit objects with zero rendered total
     * frames, which is junk data.
     */
    public static String statsListToString (List<JankStat> statsList) {
        StringBuilder result = new StringBuilder();
        for (JankStat stats : statsList) {
            result.append(stats.toString());
            result.append("\n");
        }

        return result.toString();
    }
}
